//
// This code was generated by a tool.
//
//
//   bebopc version:
//       2.4.2
//
//
//   bebopc source:
//       https://github.com/RainwayApp/bebop
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
//

#![allow(warnings)]

use ::std::io::Write as _;
use ::core::convert::TryInto as _;
use ::bebop::FixedSized as _;

#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Interface {
    Unknown = 0,
    NFTv1 = 1,
    Nft = 2,
    NFTPrintable = 3,
    NFTGroup = 4,
    FungibleAsset = 5,
    IdentityAsset = 6,
}

impl ::core::convert::TryFrom<u8> for Interface {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(Interface::Unknown),
            1 => Ok(Interface::NFTv1),
            2 => Ok(Interface::Nft),
            3 => Ok(Interface::NFTPrintable),
            4 => Ok(Interface::NFTGroup),
            5 => Ok(Interface::FungibleAsset),
            6 => Ok(Interface::IdentityAsset),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(d.into())),
        }
    }
}

impl ::core::convert::From<Interface> for u8 {
    fn from(value: Interface) -> Self {
        match value {
            Interface::Unknown => 0,
            Interface::NFTv1 => 1,
            Interface::Nft => 2,
            Interface::NFTPrintable => 3,
            Interface::NFTGroup => 4,
            Interface::FungibleAsset => 5,
            Interface::IdentityAsset => 6,
        }
    }
}

impl ::bebop::SubRecord<'_> for Interface {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize { ::std::mem::size_of::<u8>() }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for Interface {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}


#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum ModuleType {
    Invalid = 0,
    Signature = 1,
    Ownership = 2,
    Creators = 3,
    Data = 4,
    Royalty = 5,
    Rights = 6,
    Extension = 7,
}

impl ::core::convert::TryFrom<u8> for ModuleType {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(ModuleType::Invalid),
            1 => Ok(ModuleType::Signature),
            2 => Ok(ModuleType::Ownership),
            3 => Ok(ModuleType::Creators),
            4 => Ok(ModuleType::Data),
            5 => Ok(ModuleType::Royalty),
            6 => Ok(ModuleType::Rights),
            7 => Ok(ModuleType::Extension),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(d.into())),
        }
    }
}

impl ::core::convert::From<ModuleType> for u8 {
    fn from(value: ModuleType) -> Self {
        match value {
            ModuleType::Invalid => 0,
            ModuleType::Signature => 1,
            ModuleType::Ownership => 2,
            ModuleType::Creators => 3,
            ModuleType::Data => 4,
            ModuleType::Royalty => 5,
            ModuleType::Rights => 6,
            ModuleType::Extension => 7,
        }
    }
}

impl ::bebop::SubRecord<'_> for ModuleType {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize { ::std::mem::size_of::<u8>() }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for ModuleType {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}


#[derive(Clone, Debug, PartialEq)]
pub enum ModuleData<'raw> {
    /// An unknown type which is likely defined in a newer version of the schema.
    Unknown,

    /// Discriminator 1
    CreatorsData {
        creators: ::std::vec::Vec<Creator<'raw>>,
    },

    /// Discriminator 2
    OwnershipData {
        model: OwnershipModel,
        owner: ::bebop::SliceWrapper<'raw, u8>,
    },

    /// Discriminator 3
    RoyaltyData {
        royalty_percent: u8,
        model: RoyaltyModel,
        target: ::std::vec::Vec<RoyaltyTarget<'raw>>,
        locked: bool,
    },
}

impl<'raw> ::bebop::SubRecord<'raw> for ModuleData<'raw> {
    const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

    fn serialized_size(&self) -> usize {
        ::bebop::LEN_SIZE + 1 +
        match self {
            ModuleData::Unknown => {
                0
            }
            Self::CreatorsData {
                creators: ref _creators,
            }
            => {
                _creators.serialized_size()
            }
            Self::OwnershipData {
                model: ref _model,
                owner: ref _owner,
            }
            => {
                _model.serialized_size() +
                _owner.serialized_size()
            }
            Self::RoyaltyData {
                royalty_percent: ref _royalty_percent,
                model: ref _model,
                target: ref _target,
                locked: ref _locked,
            }
            => {
                _royalty_percent.serialized_size() +
                _model.serialized_size() +
                _target.serialized_size() +
                _locked.serialized_size()
            }
        }
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        let size = self.serialized_size();
        ::bebop::write_len(dest, size - ::bebop::LEN_SIZE - 1)?;
        match self {
            ModuleData::Unknown => {
                return Err(::bebop::SerializeError::CannotSerializeUnknownUnion);
            }
            Self::CreatorsData {
                creators: ref _creators,
            }
            => {
                1u8._serialize_chained(dest)?;
                _creators._serialize_chained(dest)?;
            }
            Self::OwnershipData {
                model: ref _model,
                owner: ref _owner,
            }
            => {
                2u8._serialize_chained(dest)?;
                _model._serialize_chained(dest)?;
                _owner._serialize_chained(dest)?;
            }
            Self::RoyaltyData {
                royalty_percent: ref _royalty_percent,
                model: ref _model,
                target: ref _target,
                locked: ref _locked,
            }
            => {
                3u8._serialize_chained(dest)?;
                _royalty_percent._serialize_chained(dest)?;
                _model._serialize_chained(dest)?;
                _target._serialize_chained(dest)?;
                _locked._serialize_chained(dest)?;
            }
        }
        Ok(size)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let len = ::bebop::read_len(&raw)? + ::bebop::LEN_SIZE + 1;
        let mut i = ::bebop::LEN_SIZE + 1;
        let de = match raw[::bebop::LEN_SIZE] {
            1 => {
                let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;

                ModuleData::CreatorsData {
                    creators: v0,
                }
            }
            2 => {
                let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;
                let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;

                ModuleData::OwnershipData {
                    model: v0,
                    owner: v1,
                }
            }
            3 => {
                let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;
                let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;
                let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;
                let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;

                ModuleData::RoyaltyData {
                    royalty_percent: v0,
                    model: v1,
                    target: v2,
                    locked: v3,
                }
            }
            _ => {
                i = len;
                ModuleData::Unknown
            }
        };
        if !cfg!(feature = "unchecked") && i != len {
            debug_assert!(i > len);
            Err(::bebop::DeserializeError::CorruptFrame)
        }
        else {
            Ok((i, de))
        }
    }

}

impl<'raw> ::bebop::Record<'raw> for ModuleData<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct Action<'raw> {
    pub standard: Interface,
    pub data: ActionData<'raw>,
}

impl<'raw> ::bebop::SubRecord<'raw> for Action<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <Interface>::MIN_SERIALIZED_SIZE +
        <ActionData<'raw>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.standard.serialized_size() +
        self.data.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.standard._serialize_chained(dest)? +
            self.data._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            standard: v0,
            data: v1,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Action<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub enum ActionData<'raw> {
    /// An unknown type which is likely defined in a newer version of the schema.
    Unknown,

    /// Discriminator 1
    CreateIdentity {
        uri: &'raw str,
    },

    /// Discriminator 2
    Thing {
        bill: u8,
    },
}

impl<'raw> ::bebop::SubRecord<'raw> for ActionData<'raw> {
    const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

    fn serialized_size(&self) -> usize {
        ::bebop::LEN_SIZE + 1 +
        match self {
            ActionData::Unknown => {
                0
            }
            Self::CreateIdentity {
                uri: ref _uri,
            }
            => {
                _uri.serialized_size()
            }
            Self::Thing {
                bill: ref _bill,
            }
            => {
                _bill.serialized_size()
            }
        }
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        let size = self.serialized_size();
        ::bebop::write_len(dest, size - ::bebop::LEN_SIZE - 1)?;
        match self {
            ActionData::Unknown => {
                return Err(::bebop::SerializeError::CannotSerializeUnknownUnion);
            }
            Self::CreateIdentity {
                uri: ref _uri,
            }
            => {
                1u8._serialize_chained(dest)?;
                _uri._serialize_chained(dest)?;
            }
            Self::Thing {
                bill: ref _bill,
            }
            => {
                2u8._serialize_chained(dest)?;
                _bill._serialize_chained(dest)?;
            }
        }
        Ok(size)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let len = ::bebop::read_len(&raw)? + ::bebop::LEN_SIZE + 1;
        let mut i = ::bebop::LEN_SIZE + 1;
        let de = match raw[::bebop::LEN_SIZE] {
            1 => {
                let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;

                ActionData::CreateIdentity {
                    uri: v0,
                }
            }
            2 => {
                let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;

                ActionData::Thing {
                    bill: v0,
                }
            }
            _ => {
                i = len;
                ActionData::Unknown
            }
        };
        if !cfg!(feature = "unchecked") && i != len {
            debug_assert!(i > len);
            Err(::bebop::DeserializeError::CorruptFrame)
        }
        else {
            Ok((i, de))
        }
    }

}

impl<'raw> ::bebop::Record<'raw> for ActionData<'raw> {}

pub const MAX_MODULES: i32 = 10;

#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum OwnershipModel {
    Invalid = 0,
    Single = 1,
    Token = 2,
}

impl ::core::convert::TryFrom<u8> for OwnershipModel {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(OwnershipModel::Invalid),
            1 => Ok(OwnershipModel::Single),
            2 => Ok(OwnershipModel::Token),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(d.into())),
        }
    }
}

impl ::core::convert::From<OwnershipModel> for u8 {
    fn from(value: OwnershipModel) -> Self {
        match value {
            OwnershipModel::Invalid => 0,
            OwnershipModel::Single => 1,
            OwnershipModel::Token => 2,
        }
    }
}

impl ::bebop::SubRecord<'_> for OwnershipModel {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize { ::std::mem::size_of::<u8>() }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for OwnershipModel {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}


#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum RoyaltyModel {
    Invalid = 0,
    Address = 1,
    Fanout = 2,
    Creators = 3,
}

impl ::core::convert::TryFrom<u8> for RoyaltyModel {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(RoyaltyModel::Invalid),
            1 => Ok(RoyaltyModel::Address),
            2 => Ok(RoyaltyModel::Fanout),
            3 => Ok(RoyaltyModel::Creators),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(d.into())),
        }
    }
}

impl ::core::convert::From<RoyaltyModel> for u8 {
    fn from(value: RoyaltyModel) -> Self {
        match value {
            RoyaltyModel::Invalid => 0,
            RoyaltyModel::Address => 1,
            RoyaltyModel::Fanout => 2,
            RoyaltyModel::Creators => 3,
        }
    }
}

impl ::bebop::SubRecord<'_> for RoyaltyModel {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize { ::std::mem::size_of::<u8>() }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for RoyaltyModel {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}


#[derive(Clone, Debug, PartialEq)]
pub struct RoyaltyTarget<'raw> {
    pub address: ::bebop::SliceWrapper<'raw, u8>,
    pub share: u8,
}

impl<'raw> ::bebop::SubRecord<'raw> for RoyaltyTarget<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <::bebop::SliceWrapper<'raw, u8>>::MIN_SERIALIZED_SIZE +
        <u8>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.address.serialized_size() +
        self.share.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.address._serialize_chained(dest)? +
            self.share._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            address: v0,
            share: v1,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for RoyaltyTarget<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct Creator<'raw> {
    pub address: ::bebop::SliceWrapper<'raw, u8>,
    pub share: u8,
    pub verified: bool,
}

impl<'raw> ::bebop::SubRecord<'raw> for Creator<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <::bebop::SliceWrapper<'raw, u8>>::MIN_SERIALIZED_SIZE +
        <u8>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.address.serialized_size() +
        self.share.serialized_size() +
        self.verified.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.address._serialize_chained(dest)? +
            self.share._serialize_chained(dest)? +
            self.verified._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            address: v0,
            share: v1,
            verified: v2,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Creator<'raw> {}

#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Lifecycle {
    Invalid = 0,
    Create = 1,
    Transfer = 2,
    Destroy = 3,
    Update = 4,
    Freeze = 5,
    Thaw = 6,
    Split = 7,
    Combine = 8,
    SupplyIncrease = 9,
    SupplyDecrease = 10,
    ActivateExtension = 11,
    DeactivateExtension = 12,
}

impl ::core::convert::TryFrom<u8> for Lifecycle {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(Lifecycle::Invalid),
            1 => Ok(Lifecycle::Create),
            2 => Ok(Lifecycle::Transfer),
            3 => Ok(Lifecycle::Destroy),
            4 => Ok(Lifecycle::Update),
            5 => Ok(Lifecycle::Freeze),
            6 => Ok(Lifecycle::Thaw),
            7 => Ok(Lifecycle::Split),
            8 => Ok(Lifecycle::Combine),
            9 => Ok(Lifecycle::SupplyIncrease),
            10 => Ok(Lifecycle::SupplyDecrease),
            11 => Ok(Lifecycle::ActivateExtension),
            12 => Ok(Lifecycle::DeactivateExtension),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(d.into())),
        }
    }
}

impl ::core::convert::From<Lifecycle> for u8 {
    fn from(value: Lifecycle) -> Self {
        match value {
            Lifecycle::Invalid => 0,
            Lifecycle::Create => 1,
            Lifecycle::Transfer => 2,
            Lifecycle::Destroy => 3,
            Lifecycle::Update => 4,
            Lifecycle::Freeze => 5,
            Lifecycle::Thaw => 6,
            Lifecycle::Split => 7,
            Lifecycle::Combine => 8,
            Lifecycle::SupplyIncrease => 9,
            Lifecycle::SupplyDecrease => 10,
            Lifecycle::ActivateExtension => 11,
            Lifecycle::DeactivateExtension => 12,
        }
    }
}

impl ::bebop::SubRecord<'_> for Lifecycle {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize { ::std::mem::size_of::<u8>() }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for Lifecycle {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}


#[cfg(feature = "bebop-owned-all")]
pub mod owned {
    #![allow(warnings)]

    use ::std::io::Write as _;
    use ::core::convert::TryInto as _;
    use ::bebop::FixedSized as _;

    pub use super::Interface;

    pub use super::ModuleType;

    #[derive(Clone, Debug, PartialEq)]
    pub enum ModuleData {
        /// An unknown type which is likely defined in a newer version of the schema.
        Unknown,

        /// Discriminator 1
        CreatorsData {
            creators: ::std::vec::Vec<Creator>,
        },

        /// Discriminator 2
        OwnershipData {
            model: OwnershipModel,
            owner: ::std::vec::Vec<u8>,
        },

        /// Discriminator 3
        RoyaltyData {
            royalty_percent: u8,
            model: RoyaltyModel,
            target: ::std::vec::Vec<RoyaltyTarget>,
            locked: bool,
        },
    }

    impl<'raw> ::core::convert::From<super::ModuleData<'raw>> for ModuleData {
        fn from(value: super::ModuleData) -> Self {
            match value {
                super::ModuleData::Unknown => {
                    Self::Unknown
                }
                super::ModuleData::CreatorsData {
                    creators: _creators,
                }
                => {
                    Self::CreatorsData {
                        creators: _creators.into_iter().map(|value| value.into()).collect(),
                    }
                }
                super::ModuleData::OwnershipData {
                    model: _model,
                    owner: _owner,
                }
                => {
                    Self::OwnershipData {
                        model: _model,
                        owner: _owner.iter().map(|value| value).collect(),
                    }
                }
                super::ModuleData::RoyaltyData {
                    royalty_percent: _royalty_percent,
                    model: _model,
                    target: _target,
                    locked: _locked,
                }
                => {
                    Self::RoyaltyData {
                        royalty_percent: _royalty_percent,
                        model: _model,
                        target: _target.into_iter().map(|value| value.into()).collect(),
                        locked: _locked,
                    }
                }
            }
        }

    }
    impl<'raw> ::bebop::SubRecord<'raw> for ModuleData {
        const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

        fn serialized_size(&self) -> usize {
            ::bebop::LEN_SIZE + 1 +
            match self {
                ModuleData::Unknown => {
                    0
                }
                Self::CreatorsData {
                    creators: ref _creators,
                }
                => {
                    _creators.serialized_size()
                }
                Self::OwnershipData {
                    model: ref _model,
                    owner: ref _owner,
                }
                => {
                    _model.serialized_size() +
                    _owner.serialized_size()
                }
                Self::RoyaltyData {
                    royalty_percent: ref _royalty_percent,
                    model: ref _model,
                    target: ref _target,
                    locked: ref _locked,
                }
                => {
                    _royalty_percent.serialized_size() +
                    _model.serialized_size() +
                    _target.serialized_size() +
                    _locked.serialized_size()
                }
            }
        }

        fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
            let size = self.serialized_size();
            ::bebop::write_len(dest, size - ::bebop::LEN_SIZE - 1)?;
            match self {
                ModuleData::Unknown => {
                    return Err(::bebop::SerializeError::CannotSerializeUnknownUnion);
                }
                Self::CreatorsData {
                    creators: ref _creators,
                }
                => {
                    1u8._serialize_chained(dest)?;
                    _creators._serialize_chained(dest)?;
                }
                Self::OwnershipData {
                    model: ref _model,
                    owner: ref _owner,
                }
                => {
                    2u8._serialize_chained(dest)?;
                    _model._serialize_chained(dest)?;
                    _owner._serialize_chained(dest)?;
                }
                Self::RoyaltyData {
                    royalty_percent: ref _royalty_percent,
                    model: ref _model,
                    target: ref _target,
                    locked: ref _locked,
                }
                => {
                    3u8._serialize_chained(dest)?;
                    _royalty_percent._serialize_chained(dest)?;
                    _model._serialize_chained(dest)?;
                    _target._serialize_chained(dest)?;
                    _locked._serialize_chained(dest)?;
                }
            }
            Ok(size)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let len = ::bebop::read_len(&raw)? + ::bebop::LEN_SIZE + 1;
            let mut i = ::bebop::LEN_SIZE + 1;
            let de = match raw[::bebop::LEN_SIZE] {
                1 => {
                    let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;

                    ModuleData::CreatorsData {
                        creators: v0,
                    }
                }
                2 => {
                    let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;

                    ModuleData::OwnershipData {
                        model: v0,
                        owner: v1,
                    }
                }
                3 => {
                    let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;

                    ModuleData::RoyaltyData {
                        royalty_percent: v0,
                        model: v1,
                        target: v2,
                        locked: v3,
                    }
                }
                _ => {
                    i = len;
                    ModuleData::Unknown
                }
            };
            if !cfg!(feature = "unchecked") && i != len {
                debug_assert!(i > len);
                Err(::bebop::DeserializeError::CorruptFrame)
            }
            else {
                Ok((i, de))
            }
        }

    }

    impl<'raw> ::bebop::Record<'raw> for ModuleData {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct Action {
        pub standard: Interface,
        pub data: ActionData,
    }

    impl<'raw> ::core::convert::From<super::Action<'raw>> for Action {
        fn from(value: super::Action) -> Self {
            Self {
                standard: value.standard,
                data: value.data.into(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Action {
        const MIN_SERIALIZED_SIZE: usize =
            <Interface>::MIN_SERIALIZED_SIZE +
            <ActionData>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.standard.serialized_size() +
            self.data.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
            Ok(
                self.standard._serialize_chained(dest)? +
                self.data._serialize_chained(dest)?
            )
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self {
                standard: v0,
                data: v1,
            }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Action {}

    #[derive(Clone, Debug, PartialEq)]
    pub enum ActionData {
        /// An unknown type which is likely defined in a newer version of the schema.
        Unknown,

        /// Discriminator 1
        CreateIdentity {
            uri: String,
        },

        /// Discriminator 2
        Thing {
            bill: u8,
        },
    }

    impl<'raw> ::core::convert::From<super::ActionData<'raw>> for ActionData {
        fn from(value: super::ActionData) -> Self {
            match value {
                super::ActionData::Unknown => {
                    Self::Unknown
                }
                super::ActionData::CreateIdentity {
                    uri: _uri,
                }
                => {
                    Self::CreateIdentity {
                        uri: _uri.into(),
                    }
                }
                super::ActionData::Thing {
                    bill: _bill,
                }
                => {
                    Self::Thing {
                        bill: _bill,
                    }
                }
            }
        }

    }
    impl<'raw> ::bebop::SubRecord<'raw> for ActionData {
        const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

        fn serialized_size(&self) -> usize {
            ::bebop::LEN_SIZE + 1 +
            match self {
                ActionData::Unknown => {
                    0
                }
                Self::CreateIdentity {
                    uri: ref _uri,
                }
                => {
                    _uri.serialized_size()
                }
                Self::Thing {
                    bill: ref _bill,
                }
                => {
                    _bill.serialized_size()
                }
            }
        }

        fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
            let size = self.serialized_size();
            ::bebop::write_len(dest, size - ::bebop::LEN_SIZE - 1)?;
            match self {
                ActionData::Unknown => {
                    return Err(::bebop::SerializeError::CannotSerializeUnknownUnion);
                }
                Self::CreateIdentity {
                    uri: ref _uri,
                }
                => {
                    1u8._serialize_chained(dest)?;
                    _uri._serialize_chained(dest)?;
                }
                Self::Thing {
                    bill: ref _bill,
                }
                => {
                    2u8._serialize_chained(dest)?;
                    _bill._serialize_chained(dest)?;
                }
            }
            Ok(size)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let len = ::bebop::read_len(&raw)? + ::bebop::LEN_SIZE + 1;
            let mut i = ::bebop::LEN_SIZE + 1;
            let de = match raw[::bebop::LEN_SIZE] {
                1 => {
                    let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;

                    ActionData::CreateIdentity {
                        uri: v0,
                    }
                }
                2 => {
                    let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;

                    ActionData::Thing {
                        bill: v0,
                    }
                }
                _ => {
                    i = len;
                    ActionData::Unknown
                }
            };
            if !cfg!(feature = "unchecked") && i != len {
                debug_assert!(i > len);
                Err(::bebop::DeserializeError::CorruptFrame)
            }
            else {
                Ok((i, de))
            }
        }

    }

    impl<'raw> ::bebop::Record<'raw> for ActionData {}

    pub use super::MAX_MODULES;

    pub use super::OwnershipModel;

    pub use super::RoyaltyModel;

    #[derive(Clone, Debug, PartialEq)]
    pub struct RoyaltyTarget {
        pub address: ::std::vec::Vec<u8>,
        pub share: u8,
    }

    impl<'raw> ::core::convert::From<super::RoyaltyTarget<'raw>> for RoyaltyTarget {
        fn from(value: super::RoyaltyTarget) -> Self {
            Self {
                address: value.address.iter().map(|value| value).collect(),
                share: value.share,
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for RoyaltyTarget {
        const MIN_SERIALIZED_SIZE: usize =
            <::std::vec::Vec<u8>>::MIN_SERIALIZED_SIZE +
            <u8>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.address.serialized_size() +
            self.share.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
            Ok(
                self.address._serialize_chained(dest)? +
                self.share._serialize_chained(dest)?
            )
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self {
                address: v0,
                share: v1,
            }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for RoyaltyTarget {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct Creator {
        pub address: ::std::vec::Vec<u8>,
        pub share: u8,
        pub verified: bool,
    }

    impl<'raw> ::core::convert::From<super::Creator<'raw>> for Creator {
        fn from(value: super::Creator) -> Self {
            Self {
                address: value.address.iter().map(|value| value).collect(),
                share: value.share,
                verified: value.verified,
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Creator {
        const MIN_SERIALIZED_SIZE: usize =
            <::std::vec::Vec<u8>>::MIN_SERIALIZED_SIZE +
            <u8>::MIN_SERIALIZED_SIZE +
            <bool>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.address.serialized_size() +
            self.share.serialized_size() +
            self.verified.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
            Ok(
                self.address._serialize_chained(dest)? +
                self.share._serialize_chained(dest)? +
                self.verified._serialize_chained(dest)?
            )
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self {
                address: v0,
                share: v1,
                verified: v2,
            }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Creator {}

    pub use super::Lifecycle;}
