//
// This code was generated by a tool.
//
//
//   bebopc version:
//       2.4.2
//
//
//   bebopc source:
//       https://github.com/RainwayApp/bebop
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
//

#![allow(warnings)]

use bebop::FixedSized as _;
use core::convert::TryInto as _;
use std::io::Write as _;

#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Interface {
    Unknown = 0,
    NFTv1 = 1,
    Nft = 2,
    NFTPrintable = 3,
    NFTGroup = 4,
    FungibleAsset = 5,
    IdentityAsset = 6,
}

impl ::core::convert::TryFrom<u8> for Interface {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(Interface::Unknown),
            1 => Ok(Interface::NFTv1),
            2 => Ok(Interface::Nft),
            3 => Ok(Interface::NFTPrintable),
            4 => Ok(Interface::NFTGroup),
            5 => Ok(Interface::FungibleAsset),
            6 => Ok(Interface::IdentityAsset),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<Interface> for u8 {
    fn from(value: Interface) -> Self {
        match value {
            Interface::Unknown => 0,
            Interface::NFTv1 => 1,
            Interface::Nft => 2,
            Interface::NFTPrintable => 3,
            Interface::NFTGroup => 4,
            Interface::FungibleAsset => 5,
            Interface::IdentityAsset => 6,
        }
    }
}

impl ::bebop::SubRecord<'_> for Interface {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u8>()
    }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for Interface {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}

#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum ModuleType {
    Invalid = 0,
    Signature = 1,
    Ownership = 2,
    Creators = 3,
    Data = 4,
    Royalty = 5,
    Rights = 6,
    Extension = 7,
    Governance = 8,
}

impl ::core::convert::TryFrom<u8> for ModuleType {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(ModuleType::Invalid),
            1 => Ok(ModuleType::Signature),
            2 => Ok(ModuleType::Ownership),
            3 => Ok(ModuleType::Creators),
            4 => Ok(ModuleType::Data),
            5 => Ok(ModuleType::Royalty),
            6 => Ok(ModuleType::Rights),
            7 => Ok(ModuleType::Extension),
            8 => Ok(ModuleType::Governance),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<ModuleType> for u8 {
    fn from(value: ModuleType) -> Self {
        match value {
            ModuleType::Invalid => 0,
            ModuleType::Signature => 1,
            ModuleType::Ownership => 2,
            ModuleType::Creators => 3,
            ModuleType::Data => 4,
            ModuleType::Royalty => 5,
            ModuleType::Rights => 6,
            ModuleType::Extension => 7,
            ModuleType::Governance => 8,
        }
    }
}

impl ::bebop::SubRecord<'_> for ModuleType {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u8>()
    }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for ModuleType {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}

#[derive(Clone, Debug, PartialEq)]
pub enum ModuleData<'raw> {
    /// An unknown type which is likely defined in a newer version of the schema.
    Unknown,

    /// Discriminator 1
    CreatorsData {
        /// Field 1
        creators: ::core::option::Option<::std::vec::Vec<Creator<'raw>>>,
    },

    /// Discriminator 2
    OwnershipData {
        /// Field 1
        model: ::core::option::Option<OwnershipModel>,
        /// Field 2
        owner: ::core::option::Option<::bebop::SliceWrapper<'raw, u8>>,
    },

    /// Discriminator 3
    RoyaltyData {
        /// Field 1
        royalty_bp: ::core::option::Option<u8>,
        /// Field 2
        model: ::core::option::Option<RoyaltyModel>,
        /// Field 3
        target: ::core::option::Option<::std::vec::Vec<RoyaltyTarget<'raw>>>,
        /// Field 4
        locked: ::core::option::Option<bool>,
    },

    /// Discriminator 4
    GovernanceData {
        /// Field 1
        authorities: ::core::option::Option<::std::vec::Vec<Authority<'raw>>>,
    },
}

impl<'raw> ::bebop::SubRecord<'raw> for ModuleData<'raw> {
    const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

    fn serialized_size(&self) -> usize {
        ::bebop::LEN_SIZE
            + 1
            + match self {
                ModuleData::Unknown => 0,
                Self::CreatorsData {
                    creators: ref _creators,
                } => {
                    ::bebop::LEN_SIZE
                        + 1
                        + _creators
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                }
                Self::OwnershipData {
                    model: ref _model,
                    owner: ref _owner,
                } => {
                    ::bebop::LEN_SIZE
                        + 1
                        + _model
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                        + _owner
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                }
                Self::RoyaltyData {
                    royalty_bp: ref _royalty_bp,
                    model: ref _model,
                    target: ref _target,
                    locked: ref _locked,
                } => {
                    ::bebop::LEN_SIZE
                        + 1
                        + _royalty_bp
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                        + _model
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                        + _target
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                        + _locked
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                }
                Self::GovernanceData {
                    authorities: ref _authorities,
                } => {
                    ::bebop::LEN_SIZE
                        + 1
                        + _authorities
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                }
            }
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        let size = self.serialized_size();
        ::bebop::write_len(dest, size - ::bebop::LEN_SIZE - 1)?;
        match self {
            ModuleData::Unknown => {
                return Err(::bebop::SerializeError::CannotSerializeUnknownUnion);
            }
            Self::CreatorsData {
                creators: ref _creators,
            } => {
                1u8._serialize_chained(dest)?;
                ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                if let Some(ref v) = _creators {
                    1u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                0u8._serialize_chained(dest)?;
            }
            Self::OwnershipData {
                model: ref _model,
                owner: ref _owner,
            } => {
                2u8._serialize_chained(dest)?;
                ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                if let Some(ref v) = _model {
                    1u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                if let Some(ref v) = _owner {
                    2u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                0u8._serialize_chained(dest)?;
            }
            Self::RoyaltyData {
                royalty_bp: ref _royalty_bp,
                model: ref _model,
                target: ref _target,
                locked: ref _locked,
            } => {
                3u8._serialize_chained(dest)?;
                ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                if let Some(ref v) = _royalty_bp {
                    1u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                if let Some(ref v) = _model {
                    2u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                if let Some(ref v) = _target {
                    3u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                if let Some(ref v) = _locked {
                    4u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                0u8._serialize_chained(dest)?;
            }
            Self::GovernanceData {
                authorities: ref _authorities,
            } => {
                4u8._serialize_chained(dest)?;
                ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                if let Some(ref v) = _authorities {
                    1u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                0u8._serialize_chained(dest)?;
            }
        }
        Ok(size)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let len = ::bebop::read_len(&raw)? + ::bebop::LEN_SIZE + 1;
        let mut i = ::bebop::LEN_SIZE + 1;
        let de = match raw[::bebop::LEN_SIZE] {
            1 => {
                let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                i += ::bebop::LEN_SIZE;

                #[cfg(not(feature = "unchecked"))]
                if len == 0 {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                if raw.len() < len {
                    return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                }

                let mut _creators = None;

                #[cfg(not(feature = "unchecked"))]
                let mut last = 0;

                while i < len {
                    let di = raw[i];

                    #[cfg(not(feature = "unchecked"))]
                    if di != 0 {
                        if di < last {
                            return Err(::bebop::DeserializeError::CorruptFrame);
                        }
                        last = di;
                    }

                    i += 1;
                    match di {
                        0 => {
                            break;
                        }
                        1 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _creators.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _creators = Some(value)
                        }
                        _ => {
                            i = len;
                            break;
                        }
                    }
                }

                if i != len {
                    debug_assert!(i > len);
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                ModuleData::CreatorsData {
                    creators: _creators,
                }
            }
            2 => {
                let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                i += ::bebop::LEN_SIZE;

                #[cfg(not(feature = "unchecked"))]
                if len == 0 {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                if raw.len() < len {
                    return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                }

                let mut _model = None;
                let mut _owner = None;

                #[cfg(not(feature = "unchecked"))]
                let mut last = 0;

                while i < len {
                    let di = raw[i];

                    #[cfg(not(feature = "unchecked"))]
                    if di != 0 {
                        if di < last {
                            return Err(::bebop::DeserializeError::CorruptFrame);
                        }
                        last = di;
                    }

                    i += 1;
                    match di {
                        0 => {
                            break;
                        }
                        1 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _model.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _model = Some(value)
                        }
                        2 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _owner.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _owner = Some(value)
                        }
                        _ => {
                            i = len;
                            break;
                        }
                    }
                }

                if i != len {
                    debug_assert!(i > len);
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                ModuleData::OwnershipData {
                    model: _model,
                    owner: _owner,
                }
            }
            3 => {
                let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                i += ::bebop::LEN_SIZE;

                #[cfg(not(feature = "unchecked"))]
                if len == 0 {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                if raw.len() < len {
                    return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                }

                let mut _royalty_bp = None;
                let mut _model = None;
                let mut _target = None;
                let mut _locked = None;

                #[cfg(not(feature = "unchecked"))]
                let mut last = 0;

                while i < len {
                    let di = raw[i];

                    #[cfg(not(feature = "unchecked"))]
                    if di != 0 {
                        if di < last {
                            return Err(::bebop::DeserializeError::CorruptFrame);
                        }
                        last = di;
                    }

                    i += 1;
                    match di {
                        0 => {
                            break;
                        }
                        1 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _royalty_bp.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _royalty_bp = Some(value)
                        }
                        2 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _model.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _model = Some(value)
                        }
                        3 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _target.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _target = Some(value)
                        }
                        4 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _locked.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _locked = Some(value)
                        }
                        _ => {
                            i = len;
                            break;
                        }
                    }
                }

                if i != len {
                    debug_assert!(i > len);
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                ModuleData::RoyaltyData {
                    royalty_bp: _royalty_bp,
                    model: _model,
                    target: _target,
                    locked: _locked,
                }
            }
            4 => {
                let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                i += ::bebop::LEN_SIZE;

                #[cfg(not(feature = "unchecked"))]
                if len == 0 {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                if raw.len() < len {
                    return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                }

                let mut _authorities = None;

                #[cfg(not(feature = "unchecked"))]
                let mut last = 0;

                while i < len {
                    let di = raw[i];

                    #[cfg(not(feature = "unchecked"))]
                    if di != 0 {
                        if di < last {
                            return Err(::bebop::DeserializeError::CorruptFrame);
                        }
                        last = di;
                    }

                    i += 1;
                    match di {
                        0 => {
                            break;
                        }
                        1 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _authorities.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _authorities = Some(value)
                        }
                        _ => {
                            i = len;
                            break;
                        }
                    }
                }

                if i != len {
                    debug_assert!(i > len);
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                ModuleData::GovernanceData {
                    authorities: _authorities,
                }
            }
            _ => {
                i = len;
                ModuleData::Unknown
            }
        };
        if !cfg!(feature = "unchecked") && i != len {
            debug_assert!(i > len);
            Err(::bebop::DeserializeError::CorruptFrame)
        } else {
            Ok((i, de))
        }
    }
}

impl<'raw> ::bebop::Record<'raw> for ModuleData<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct Authority<'raw> {
    pub scopes: ::std::vec::Vec<&'raw str>,
    pub address: ::bebop::SliceWrapper<'raw, u8>,
}

impl<'raw> ::bebop::SubRecord<'raw> for Authority<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <::std::vec::Vec<&'raw str>>::MIN_SERIALIZED_SIZE
        + <::bebop::SliceWrapper<'raw, u8>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.scopes.serialized_size() + self.address.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(self.scopes._serialize_chained(dest)? + self.address._serialize_chained(dest)?)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                scopes: v0,
                address: v1,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Authority<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct Action<'raw> {
    pub standard: Interface,
    pub data: ActionData<'raw>,
}

impl<'raw> ::bebop::SubRecord<'raw> for Action<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <Interface>::MIN_SERIALIZED_SIZE + <ActionData<'raw>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.standard.serialized_size() + self.data.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(self.standard._serialize_chained(dest)? + self.data._serialize_chained(dest)?)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                standard: v0,
                data: v1,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Action<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub enum ActionData<'raw> {
    /// An unknown type which is likely defined in a newer version of the schema.
    Unknown,

    /// Discriminator 1
    Nft {
        /// Field 1
        create: ::core::option::Option<NFTCreate<'raw>>,
    },
}

impl<'raw> ::bebop::SubRecord<'raw> for ActionData<'raw> {
    const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

    fn serialized_size(&self) -> usize {
        ::bebop::LEN_SIZE
            + 1
            + match self {
                ActionData::Unknown => 0,
                Self::Nft {
                    create: ref _create,
                } => {
                    ::bebop::LEN_SIZE
                        + 1
                        + _create
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                }
            }
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        let size = self.serialized_size();
        ::bebop::write_len(dest, size - ::bebop::LEN_SIZE - 1)?;
        match self {
            ActionData::Unknown => {
                return Err(::bebop::SerializeError::CannotSerializeUnknownUnion);
            }
            Self::Nft {
                create: ref _create,
            } => {
                1u8._serialize_chained(dest)?;
                ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                if let Some(ref v) = _create {
                    1u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                0u8._serialize_chained(dest)?;
            }
        }
        Ok(size)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let len = ::bebop::read_len(&raw)? + ::bebop::LEN_SIZE + 1;
        let mut i = ::bebop::LEN_SIZE + 1;
        let de = match raw[::bebop::LEN_SIZE] {
            1 => {
                let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                i += ::bebop::LEN_SIZE;

                #[cfg(not(feature = "unchecked"))]
                if len == 0 {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                if raw.len() < len {
                    return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                }

                let mut _create = None;

                #[cfg(not(feature = "unchecked"))]
                let mut last = 0;

                while i < len {
                    let di = raw[i];

                    #[cfg(not(feature = "unchecked"))]
                    if di != 0 {
                        if di < last {
                            return Err(::bebop::DeserializeError::CorruptFrame);
                        }
                        last = di;
                    }

                    i += 1;
                    match di {
                        0 => {
                            break;
                        }
                        1 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _create.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _create = Some(value)
                        }
                        _ => {
                            i = len;
                            break;
                        }
                    }
                }

                if i != len {
                    debug_assert!(i > len);
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                ActionData::Nft { create: _create }
            }
            _ => {
                i = len;
                ActionData::Unknown
            }
        };
        if !cfg!(feature = "unchecked") && i != len {
            debug_assert!(i > len);
            Err(::bebop::DeserializeError::CorruptFrame)
        } else {
            Ok((i, de))
        }
    }
}

impl<'raw> ::bebop::Record<'raw> for ActionData<'raw> {}

#[derive(Clone, Debug, PartialEq, Default)]
pub struct NFTCreate<'raw> {
    /// Field 1
    pub uri: ::core::option::Option<&'raw str>,
    /// Field 2
    pub ownership_model: ::core::option::Option<OwnershipModel>,
    /// Field 3
    pub royalty: ::core::option::Option<RoyaltyConfiguration<'raw>>,
    /// Field 4
    pub creators: ::core::option::Option<::std::vec::Vec<Creator<'raw>>>,
    /// Field 5
    pub compress: ::core::option::Option<bool>,
    /// Field 6
    pub authorities: ::core::option::Option<::std::vec::Vec<Authority<'raw>>>,
}

impl<'raw> ::bebop::SubRecord<'raw> for NFTCreate<'raw> {
    const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

    #[inline]
    fn serialized_size(&self) -> usize {
        ::bebop::LEN_SIZE
            + 1
            + self
                .uri
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .ownership_model
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .royalty
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .creators
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .compress
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .authorities
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        let size = self.serialized_size();
        ::bebop::write_len(dest, size - ::bebop::LEN_SIZE)?;
        if let Some(ref v) = self.uri {
            1u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.ownership_model {
            2u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.royalty {
            3u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.creators {
            4u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.compress {
            5u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.authorities {
            6u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        0u8._serialize_chained(dest)?;
        Ok(size)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        let len = ::bebop::read_len(&raw[i..])? + ::bebop::LEN_SIZE;
        i += ::bebop::LEN_SIZE;

        #[cfg(not(feature = "unchecked"))]
        if len == 0 {
            return Err(::bebop::DeserializeError::CorruptFrame);
        }

        if raw.len() < len {
            return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
        }

        let mut _uri = None;
        let mut _ownership_model = None;
        let mut _royalty = None;
        let mut _creators = None;
        let mut _compress = None;
        let mut _authorities = None;

        #[cfg(not(feature = "unchecked"))]
        let mut last = 0;

        while i < len {
            let di = raw[i];

            #[cfg(not(feature = "unchecked"))]
            if di != 0 {
                if di < last {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }
                last = di;
            }

            i += 1;
            match di {
                0 => {
                    break;
                }
                1 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _uri.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _uri = Some(value)
                }
                2 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _ownership_model.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _ownership_model = Some(value)
                }
                3 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _royalty.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _royalty = Some(value)
                }
                4 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _creators.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _creators = Some(value)
                }
                5 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _compress.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _compress = Some(value)
                }
                6 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _authorities.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _authorities = Some(value)
                }
                _ => {
                    i = len;
                    break;
                }
            }
        }

        if i != len {
            debug_assert!(i > len);
            return Err(::bebop::DeserializeError::CorruptFrame);
        }

        Ok((
            i,
            Self {
                uri: _uri,
                ownership_model: _ownership_model,
                royalty: _royalty,
                creators: _creators,
                compress: _compress,
                authorities: _authorities,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for NFTCreate<'raw> {}

pub const MAX_MODULES: i32 = 10;

#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum OwnershipModel {
    Invalid = 0,
    Single = 1,
    Token = 2,
}

impl ::core::convert::TryFrom<u8> for OwnershipModel {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(OwnershipModel::Invalid),
            1 => Ok(OwnershipModel::Single),
            2 => Ok(OwnershipModel::Token),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<OwnershipModel> for u8 {
    fn from(value: OwnershipModel) -> Self {
        match value {
            OwnershipModel::Invalid => 0,
            OwnershipModel::Single => 1,
            OwnershipModel::Token => 2,
        }
    }
}

impl ::bebop::SubRecord<'_> for OwnershipModel {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u8>()
    }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for OwnershipModel {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}

#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum RoyaltyModel {
    Invalid = 0,
    Address = 1,
    Fanout = 2,
    Creators = 3,
}

impl ::core::convert::TryFrom<u8> for RoyaltyModel {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(RoyaltyModel::Invalid),
            1 => Ok(RoyaltyModel::Address),
            2 => Ok(RoyaltyModel::Fanout),
            3 => Ok(RoyaltyModel::Creators),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<RoyaltyModel> for u8 {
    fn from(value: RoyaltyModel) -> Self {
        match value {
            RoyaltyModel::Invalid => 0,
            RoyaltyModel::Address => 1,
            RoyaltyModel::Fanout => 2,
            RoyaltyModel::Creators => 3,
        }
    }
}

impl ::bebop::SubRecord<'_> for RoyaltyModel {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u8>()
    }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for RoyaltyModel {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}

#[derive(Clone, Debug, PartialEq, Default)]
pub struct RoyaltyConfiguration<'raw> {
    /// Field 1
    pub royalty_model: ::core::option::Option<RoyaltyModel>,
    /// Field 2
    pub royalty_bp: ::core::option::Option<u16>,
    /// Field 3
    pub royalty_target: ::core::option::Option<RoyaltyTarget<'raw>>,
}

impl<'raw> ::bebop::SubRecord<'raw> for RoyaltyConfiguration<'raw> {
    const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

    #[inline]
    fn serialized_size(&self) -> usize {
        ::bebop::LEN_SIZE
            + 1
            + self
                .royalty_model
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .royalty_bp
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .royalty_target
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        let size = self.serialized_size();
        ::bebop::write_len(dest, size - ::bebop::LEN_SIZE)?;
        if let Some(ref v) = self.royalty_model {
            1u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.royalty_bp {
            2u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.royalty_target {
            3u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        0u8._serialize_chained(dest)?;
        Ok(size)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        let len = ::bebop::read_len(&raw[i..])? + ::bebop::LEN_SIZE;
        i += ::bebop::LEN_SIZE;

        #[cfg(not(feature = "unchecked"))]
        if len == 0 {
            return Err(::bebop::DeserializeError::CorruptFrame);
        }

        if raw.len() < len {
            return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
        }

        let mut _royalty_model = None;
        let mut _royalty_bp = None;
        let mut _royalty_target = None;

        #[cfg(not(feature = "unchecked"))]
        let mut last = 0;

        while i < len {
            let di = raw[i];

            #[cfg(not(feature = "unchecked"))]
            if di != 0 {
                if di < last {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }
                last = di;
            }

            i += 1;
            match di {
                0 => {
                    break;
                }
                1 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _royalty_model.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _royalty_model = Some(value)
                }
                2 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _royalty_bp.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _royalty_bp = Some(value)
                }
                3 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _royalty_target.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _royalty_target = Some(value)
                }
                _ => {
                    i = len;
                    break;
                }
            }
        }

        if i != len {
            debug_assert!(i > len);
            return Err(::bebop::DeserializeError::CorruptFrame);
        }

        Ok((
            i,
            Self {
                royalty_model: _royalty_model,
                royalty_bp: _royalty_bp,
                royalty_target: _royalty_target,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for RoyaltyConfiguration<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct RoyaltyTarget<'raw> {
    pub address: ::bebop::SliceWrapper<'raw, u8>,
    pub share: u8,
}

impl<'raw> ::bebop::SubRecord<'raw> for RoyaltyTarget<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <::bebop::SliceWrapper<'raw, u8>>::MIN_SERIALIZED_SIZE + <u8>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.address.serialized_size() + self.share.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(self.address._serialize_chained(dest)? + self.share._serialize_chained(dest)?)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                address: v0,
                share: v1,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for RoyaltyTarget<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct Creator<'raw> {
    pub address: ::bebop::SliceWrapper<'raw, u8>,
    pub share: u8,
    pub verified: bool,
}

impl<'raw> ::bebop::SubRecord<'raw> for Creator<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <::bebop::SliceWrapper<'raw, u8>>::MIN_SERIALIZED_SIZE
        + <u8>::MIN_SERIALIZED_SIZE
        + <bool>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.address.serialized_size()
            + self.share.serialized_size()
            + self.verified.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(self.address._serialize_chained(dest)?
            + self.share._serialize_chained(dest)?
            + self.verified._serialize_chained(dest)?)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                address: v0,
                share: v1,
                verified: v2,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Creator<'raw> {}

#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Lifecycle {
    Invalid = 0,
    Create = 1,
    Transfer = 2,
    Destroy = 3,
    Update = 4,
    Freeze = 5,
    Thaw = 6,
    Split = 7,
    Combine = 8,
    SupplyIncrease = 9,
    SupplyDecrease = 10,
    ActivateExtension = 11,
    DeactivateExtension = 12,
}

impl ::core::convert::TryFrom<u8> for Lifecycle {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(Lifecycle::Invalid),
            1 => Ok(Lifecycle::Create),
            2 => Ok(Lifecycle::Transfer),
            3 => Ok(Lifecycle::Destroy),
            4 => Ok(Lifecycle::Update),
            5 => Ok(Lifecycle::Freeze),
            6 => Ok(Lifecycle::Thaw),
            7 => Ok(Lifecycle::Split),
            8 => Ok(Lifecycle::Combine),
            9 => Ok(Lifecycle::SupplyIncrease),
            10 => Ok(Lifecycle::SupplyDecrease),
            11 => Ok(Lifecycle::ActivateExtension),
            12 => Ok(Lifecycle::DeactivateExtension),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<Lifecycle> for u8 {
    fn from(value: Lifecycle) -> Self {
        match value {
            Lifecycle::Invalid => 0,
            Lifecycle::Create => 1,
            Lifecycle::Transfer => 2,
            Lifecycle::Destroy => 3,
            Lifecycle::Update => 4,
            Lifecycle::Freeze => 5,
            Lifecycle::Thaw => 6,
            Lifecycle::Split => 7,
            Lifecycle::Combine => 8,
            Lifecycle::SupplyIncrease => 9,
            Lifecycle::SupplyDecrease => 10,
            Lifecycle::ActivateExtension => 11,
            Lifecycle::DeactivateExtension => 12,
        }
    }
}

impl ::bebop::SubRecord<'_> for Lifecycle {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u8>()
    }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for Lifecycle {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}

#[cfg(feature = "bebop-owned-all")]
pub mod owned {
    #![allow(warnings)]

    use bebop::FixedSized as _;
    use core::convert::TryInto as _;
    use std::io::Write as _;

    pub use super::Interface;

    pub use super::ModuleType;

    #[derive(Clone, Debug, PartialEq)]
    pub enum ModuleData {
        /// An unknown type which is likely defined in a newer version of the schema.
        Unknown,

        /// Discriminator 1
        CreatorsData {
            /// Field 1
            creators: ::core::option::Option<::std::vec::Vec<Creator>>,
        },

        /// Discriminator 2
        OwnershipData {
            /// Field 1
            model: ::core::option::Option<OwnershipModel>,
            /// Field 2
            owner: ::core::option::Option<::std::vec::Vec<u8>>,
        },

        /// Discriminator 3
        RoyaltyData {
            /// Field 1
            royalty_bp: ::core::option::Option<u8>,
            /// Field 2
            model: ::core::option::Option<RoyaltyModel>,
            /// Field 3
            target: ::core::option::Option<::std::vec::Vec<RoyaltyTarget>>,
            /// Field 4
            locked: ::core::option::Option<bool>,
        },

        /// Discriminator 4
        GovernanceData {
            /// Field 1
            authorities: ::core::option::Option<::std::vec::Vec<Authority>>,
        },
    }

    impl<'raw> ::core::convert::From<super::ModuleData<'raw>> for ModuleData {
        fn from(value: super::ModuleData) -> Self {
            match value {
                super::ModuleData::Unknown => Self::Unknown,
                super::ModuleData::CreatorsData {
                    creators: _creators,
                } => Self::CreatorsData {
                    creators: _creators
                        .map(|value| value.into_iter().map(|value| value.into()).collect()),
                },
                super::ModuleData::OwnershipData {
                    model: _model,
                    owner: _owner,
                } => Self::OwnershipData {
                    model: _model,
                    owner: _owner.map(|value| value.iter().map(|value| value).collect()),
                },
                super::ModuleData::RoyaltyData {
                    royalty_bp: _royalty_bp,
                    model: _model,
                    target: _target,
                    locked: _locked,
                } => Self::RoyaltyData {
                    royalty_bp: _royalty_bp,
                    model: _model,
                    target: _target
                        .map(|value| value.into_iter().map(|value| value.into()).collect()),
                    locked: _locked,
                },
                super::ModuleData::GovernanceData {
                    authorities: _authorities,
                } => Self::GovernanceData {
                    authorities: _authorities
                        .map(|value| value.into_iter().map(|value| value.into()).collect()),
                },
            }
        }
    }
    impl<'raw> ::bebop::SubRecord<'raw> for ModuleData {
        const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

        fn serialized_size(&self) -> usize {
            ::bebop::LEN_SIZE
                + 1
                + match self {
                    ModuleData::Unknown => 0,
                    Self::CreatorsData {
                        creators: ref _creators,
                    } => {
                        ::bebop::LEN_SIZE
                            + 1
                            + _creators
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                    }
                    Self::OwnershipData {
                        model: ref _model,
                        owner: ref _owner,
                    } => {
                        ::bebop::LEN_SIZE
                            + 1
                            + _model
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                            + _owner
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                    }
                    Self::RoyaltyData {
                        royalty_bp: ref _royalty_bp,
                        model: ref _model,
                        target: ref _target,
                        locked: ref _locked,
                    } => {
                        ::bebop::LEN_SIZE
                            + 1
                            + _royalty_bp
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                            + _model
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                            + _target
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                            + _locked
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                    }
                    Self::GovernanceData {
                        authorities: ref _authorities,
                    } => {
                        ::bebop::LEN_SIZE
                            + 1
                            + _authorities
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                    }
                }
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            let size = self.serialized_size();
            ::bebop::write_len(dest, size - ::bebop::LEN_SIZE - 1)?;
            match self {
                ModuleData::Unknown => {
                    return Err(::bebop::SerializeError::CannotSerializeUnknownUnion);
                }
                Self::CreatorsData {
                    creators: ref _creators,
                } => {
                    1u8._serialize_chained(dest)?;
                    ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                    if let Some(ref v) = _creators {
                        1u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    0u8._serialize_chained(dest)?;
                }
                Self::OwnershipData {
                    model: ref _model,
                    owner: ref _owner,
                } => {
                    2u8._serialize_chained(dest)?;
                    ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                    if let Some(ref v) = _model {
                        1u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    if let Some(ref v) = _owner {
                        2u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    0u8._serialize_chained(dest)?;
                }
                Self::RoyaltyData {
                    royalty_bp: ref _royalty_bp,
                    model: ref _model,
                    target: ref _target,
                    locked: ref _locked,
                } => {
                    3u8._serialize_chained(dest)?;
                    ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                    if let Some(ref v) = _royalty_bp {
                        1u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    if let Some(ref v) = _model {
                        2u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    if let Some(ref v) = _target {
                        3u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    if let Some(ref v) = _locked {
                        4u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    0u8._serialize_chained(dest)?;
                }
                Self::GovernanceData {
                    authorities: ref _authorities,
                } => {
                    4u8._serialize_chained(dest)?;
                    ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                    if let Some(ref v) = _authorities {
                        1u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    0u8._serialize_chained(dest)?;
                }
            }
            Ok(size)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let len = ::bebop::read_len(&raw)? + ::bebop::LEN_SIZE + 1;
            let mut i = ::bebop::LEN_SIZE + 1;
            let de = match raw[::bebop::LEN_SIZE] {
                1 => {
                    let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                    i += ::bebop::LEN_SIZE;

                    #[cfg(not(feature = "unchecked"))]
                    if len == 0 {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    if raw.len() < len {
                        return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                    }

                    let mut _creators = None;

                    #[cfg(not(feature = "unchecked"))]
                    let mut last = 0;

                    while i < len {
                        let di = raw[i];

                        #[cfg(not(feature = "unchecked"))]
                        if di != 0 {
                            if di < last {
                                return Err(::bebop::DeserializeError::CorruptFrame);
                            }
                            last = di;
                        }

                        i += 1;
                        match di {
                            0 => {
                                break;
                            }
                            1 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _creators.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _creators = Some(value)
                            }
                            _ => {
                                i = len;
                                break;
                            }
                        }
                    }

                    if i != len {
                        debug_assert!(i > len);
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    ModuleData::CreatorsData {
                        creators: _creators,
                    }
                }
                2 => {
                    let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                    i += ::bebop::LEN_SIZE;

                    #[cfg(not(feature = "unchecked"))]
                    if len == 0 {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    if raw.len() < len {
                        return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                    }

                    let mut _model = None;
                    let mut _owner = None;

                    #[cfg(not(feature = "unchecked"))]
                    let mut last = 0;

                    while i < len {
                        let di = raw[i];

                        #[cfg(not(feature = "unchecked"))]
                        if di != 0 {
                            if di < last {
                                return Err(::bebop::DeserializeError::CorruptFrame);
                            }
                            last = di;
                        }

                        i += 1;
                        match di {
                            0 => {
                                break;
                            }
                            1 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _model.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _model = Some(value)
                            }
                            2 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _owner.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _owner = Some(value)
                            }
                            _ => {
                                i = len;
                                break;
                            }
                        }
                    }

                    if i != len {
                        debug_assert!(i > len);
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    ModuleData::OwnershipData {
                        model: _model,
                        owner: _owner,
                    }
                }
                3 => {
                    let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                    i += ::bebop::LEN_SIZE;

                    #[cfg(not(feature = "unchecked"))]
                    if len == 0 {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    if raw.len() < len {
                        return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                    }

                    let mut _royalty_bp = None;
                    let mut _model = None;
                    let mut _target = None;
                    let mut _locked = None;

                    #[cfg(not(feature = "unchecked"))]
                    let mut last = 0;

                    while i < len {
                        let di = raw[i];

                        #[cfg(not(feature = "unchecked"))]
                        if di != 0 {
                            if di < last {
                                return Err(::bebop::DeserializeError::CorruptFrame);
                            }
                            last = di;
                        }

                        i += 1;
                        match di {
                            0 => {
                                break;
                            }
                            1 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _royalty_bp.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _royalty_bp = Some(value)
                            }
                            2 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _model.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _model = Some(value)
                            }
                            3 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _target.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _target = Some(value)
                            }
                            4 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _locked.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _locked = Some(value)
                            }
                            _ => {
                                i = len;
                                break;
                            }
                        }
                    }

                    if i != len {
                        debug_assert!(i > len);
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    ModuleData::RoyaltyData {
                        royalty_bp: _royalty_bp,
                        model: _model,
                        target: _target,
                        locked: _locked,
                    }
                }
                4 => {
                    let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                    i += ::bebop::LEN_SIZE;

                    #[cfg(not(feature = "unchecked"))]
                    if len == 0 {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    if raw.len() < len {
                        return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                    }

                    let mut _authorities = None;

                    #[cfg(not(feature = "unchecked"))]
                    let mut last = 0;

                    while i < len {
                        let di = raw[i];

                        #[cfg(not(feature = "unchecked"))]
                        if di != 0 {
                            if di < last {
                                return Err(::bebop::DeserializeError::CorruptFrame);
                            }
                            last = di;
                        }

                        i += 1;
                        match di {
                            0 => {
                                break;
                            }
                            1 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _authorities.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _authorities = Some(value)
                            }
                            _ => {
                                i = len;
                                break;
                            }
                        }
                    }

                    if i != len {
                        debug_assert!(i > len);
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    ModuleData::GovernanceData {
                        authorities: _authorities,
                    }
                }
                _ => {
                    i = len;
                    ModuleData::Unknown
                }
            };
            if !cfg!(feature = "unchecked") && i != len {
                debug_assert!(i > len);
                Err(::bebop::DeserializeError::CorruptFrame)
            } else {
                Ok((i, de))
            }
        }
    }

    impl<'raw> ::bebop::Record<'raw> for ModuleData {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct Authority {
        pub scopes: ::std::vec::Vec<String>,
        pub address: ::std::vec::Vec<u8>,
    }

    impl<'raw> ::core::convert::From<super::Authority<'raw>> for Authority {
        fn from(value: super::Authority) -> Self {
            Self {
                scopes: value.scopes.into_iter().map(|value| value.into()).collect(),
                address: value.address.iter().map(|value| value).collect(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Authority {
        const MIN_SERIALIZED_SIZE: usize = <::std::vec::Vec<String>>::MIN_SERIALIZED_SIZE
            + <::std::vec::Vec<u8>>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.scopes.serialized_size() + self.address.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            Ok(self.scopes._serialize_chained(dest)? + self.address._serialize_chained(dest)?)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    scopes: v0,
                    address: v1,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Authority {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct Action {
        pub standard: Interface,
        pub data: ActionData,
    }

    impl<'raw> ::core::convert::From<super::Action<'raw>> for Action {
        fn from(value: super::Action) -> Self {
            Self {
                standard: value.standard,
                data: value.data.into(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Action {
        const MIN_SERIALIZED_SIZE: usize =
            <Interface>::MIN_SERIALIZED_SIZE + <ActionData>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.standard.serialized_size() + self.data.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            Ok(self.standard._serialize_chained(dest)? + self.data._serialize_chained(dest)?)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    standard: v0,
                    data: v1,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Action {}

    #[derive(Clone, Debug, PartialEq)]
    pub enum ActionData {
        /// An unknown type which is likely defined in a newer version of the schema.
        Unknown,

        /// Discriminator 1
        Nft {
            /// Field 1
            create: ::core::option::Option<NFTCreate>,
        },
    }

    impl<'raw> ::core::convert::From<super::ActionData<'raw>> for ActionData {
        fn from(value: super::ActionData) -> Self {
            match value {
                super::ActionData::Unknown => Self::Unknown,
                super::ActionData::Nft { create: _create } => Self::Nft {
                    create: _create.map(|value| value.into()),
                },
            }
        }
    }
    impl<'raw> ::bebop::SubRecord<'raw> for ActionData {
        const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

        fn serialized_size(&self) -> usize {
            ::bebop::LEN_SIZE
                + 1
                + match self {
                    ActionData::Unknown => 0,
                    Self::Nft {
                        create: ref _create,
                    } => {
                        ::bebop::LEN_SIZE
                            + 1
                            + _create
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                    }
                }
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            let size = self.serialized_size();
            ::bebop::write_len(dest, size - ::bebop::LEN_SIZE - 1)?;
            match self {
                ActionData::Unknown => {
                    return Err(::bebop::SerializeError::CannotSerializeUnknownUnion);
                }
                Self::Nft {
                    create: ref _create,
                } => {
                    1u8._serialize_chained(dest)?;
                    ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                    if let Some(ref v) = _create {
                        1u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    0u8._serialize_chained(dest)?;
                }
            }
            Ok(size)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let len = ::bebop::read_len(&raw)? + ::bebop::LEN_SIZE + 1;
            let mut i = ::bebop::LEN_SIZE + 1;
            let de = match raw[::bebop::LEN_SIZE] {
                1 => {
                    let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                    i += ::bebop::LEN_SIZE;

                    #[cfg(not(feature = "unchecked"))]
                    if len == 0 {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    if raw.len() < len {
                        return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                    }

                    let mut _create = None;

                    #[cfg(not(feature = "unchecked"))]
                    let mut last = 0;

                    while i < len {
                        let di = raw[i];

                        #[cfg(not(feature = "unchecked"))]
                        if di != 0 {
                            if di < last {
                                return Err(::bebop::DeserializeError::CorruptFrame);
                            }
                            last = di;
                        }

                        i += 1;
                        match di {
                            0 => {
                                break;
                            }
                            1 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _create.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _create = Some(value)
                            }
                            _ => {
                                i = len;
                                break;
                            }
                        }
                    }

                    if i != len {
                        debug_assert!(i > len);
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    ActionData::Nft { create: _create }
                }
                _ => {
                    i = len;
                    ActionData::Unknown
                }
            };
            if !cfg!(feature = "unchecked") && i != len {
                debug_assert!(i > len);
                Err(::bebop::DeserializeError::CorruptFrame)
            } else {
                Ok((i, de))
            }
        }
    }

    impl<'raw> ::bebop::Record<'raw> for ActionData {}

    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct NFTCreate {
        /// Field 1
        pub uri: ::core::option::Option<String>,
        /// Field 2
        pub ownership_model: ::core::option::Option<OwnershipModel>,
        /// Field 3
        pub royalty: ::core::option::Option<RoyaltyConfiguration>,
        /// Field 4
        pub creators: ::core::option::Option<::std::vec::Vec<Creator>>,
        /// Field 5
        pub compress: ::core::option::Option<bool>,
        /// Field 6
        pub authorities: ::core::option::Option<::std::vec::Vec<Authority>>,
    }

    impl<'raw> ::core::convert::From<super::NFTCreate<'raw>> for NFTCreate {
        fn from(value: super::NFTCreate) -> Self {
            Self {
                uri: value.uri.map(|value| value.into()),
                ownership_model: value.ownership_model,
                royalty: value.royalty.map(|value| value.into()),
                creators: value
                    .creators
                    .map(|value| value.into_iter().map(|value| value.into()).collect()),
                compress: value.compress,
                authorities: value
                    .authorities
                    .map(|value| value.into_iter().map(|value| value.into()).collect()),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for NFTCreate {
        const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

        #[inline]
        fn serialized_size(&self) -> usize {
            ::bebop::LEN_SIZE
                + 1
                + self
                    .uri
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .ownership_model
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .royalty
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .creators
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .compress
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .authorities
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            let size = self.serialized_size();
            ::bebop::write_len(dest, size - ::bebop::LEN_SIZE)?;
            if let Some(ref v) = self.uri {
                1u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.ownership_model {
                2u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.royalty {
                3u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.creators {
                4u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.compress {
                5u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.authorities {
                6u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            0u8._serialize_chained(dest)?;
            Ok(size)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            let len = ::bebop::read_len(&raw[i..])? + ::bebop::LEN_SIZE;
            i += ::bebop::LEN_SIZE;

            #[cfg(not(feature = "unchecked"))]
            if len == 0 {
                return Err(::bebop::DeserializeError::CorruptFrame);
            }

            if raw.len() < len {
                return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
            }

            let mut _uri = None;
            let mut _ownership_model = None;
            let mut _royalty = None;
            let mut _creators = None;
            let mut _compress = None;
            let mut _authorities = None;

            #[cfg(not(feature = "unchecked"))]
            let mut last = 0;

            while i < len {
                let di = raw[i];

                #[cfg(not(feature = "unchecked"))]
                if di != 0 {
                    if di < last {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }
                    last = di;
                }

                i += 1;
                match di {
                    0 => {
                        break;
                    }
                    1 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _uri.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _uri = Some(value)
                    }
                    2 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _ownership_model.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _ownership_model = Some(value)
                    }
                    3 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _royalty.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _royalty = Some(value)
                    }
                    4 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _creators.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _creators = Some(value)
                    }
                    5 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _compress.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _compress = Some(value)
                    }
                    6 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _authorities.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _authorities = Some(value)
                    }
                    _ => {
                        i = len;
                        break;
                    }
                }
            }

            if i != len {
                debug_assert!(i > len);
                return Err(::bebop::DeserializeError::CorruptFrame);
            }

            Ok((
                i,
                Self {
                    uri: _uri,
                    ownership_model: _ownership_model,
                    royalty: _royalty,
                    creators: _creators,
                    compress: _compress,
                    authorities: _authorities,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for NFTCreate {}

    pub use super::MAX_MODULES;

    pub use super::OwnershipModel;

    pub use super::RoyaltyModel;

    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct RoyaltyConfiguration {
        /// Field 1
        pub royalty_model: ::core::option::Option<RoyaltyModel>,
        /// Field 2
        pub royalty_bp: ::core::option::Option<u16>,
        /// Field 3
        pub royalty_target: ::core::option::Option<RoyaltyTarget>,
    }

    impl<'raw> ::core::convert::From<super::RoyaltyConfiguration<'raw>> for RoyaltyConfiguration {
        fn from(value: super::RoyaltyConfiguration) -> Self {
            Self {
                royalty_model: value.royalty_model,
                royalty_bp: value.royalty_bp,
                royalty_target: value.royalty_target.map(|value| value.into()),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for RoyaltyConfiguration {
        const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

        #[inline]
        fn serialized_size(&self) -> usize {
            ::bebop::LEN_SIZE
                + 1
                + self
                    .royalty_model
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .royalty_bp
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .royalty_target
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            let size = self.serialized_size();
            ::bebop::write_len(dest, size - ::bebop::LEN_SIZE)?;
            if let Some(ref v) = self.royalty_model {
                1u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.royalty_bp {
                2u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.royalty_target {
                3u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            0u8._serialize_chained(dest)?;
            Ok(size)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            let len = ::bebop::read_len(&raw[i..])? + ::bebop::LEN_SIZE;
            i += ::bebop::LEN_SIZE;

            #[cfg(not(feature = "unchecked"))]
            if len == 0 {
                return Err(::bebop::DeserializeError::CorruptFrame);
            }

            if raw.len() < len {
                return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
            }

            let mut _royalty_model = None;
            let mut _royalty_bp = None;
            let mut _royalty_target = None;

            #[cfg(not(feature = "unchecked"))]
            let mut last = 0;

            while i < len {
                let di = raw[i];

                #[cfg(not(feature = "unchecked"))]
                if di != 0 {
                    if di < last {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }
                    last = di;
                }

                i += 1;
                match di {
                    0 => {
                        break;
                    }
                    1 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _royalty_model.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _royalty_model = Some(value)
                    }
                    2 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _royalty_bp.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _royalty_bp = Some(value)
                    }
                    3 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _royalty_target.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _royalty_target = Some(value)
                    }
                    _ => {
                        i = len;
                        break;
                    }
                }
            }

            if i != len {
                debug_assert!(i > len);
                return Err(::bebop::DeserializeError::CorruptFrame);
            }

            Ok((
                i,
                Self {
                    royalty_model: _royalty_model,
                    royalty_bp: _royalty_bp,
                    royalty_target: _royalty_target,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for RoyaltyConfiguration {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct RoyaltyTarget {
        pub address: ::std::vec::Vec<u8>,
        pub share: u8,
    }

    impl<'raw> ::core::convert::From<super::RoyaltyTarget<'raw>> for RoyaltyTarget {
        fn from(value: super::RoyaltyTarget) -> Self {
            Self {
                address: value.address.iter().map(|value| value).collect(),
                share: value.share,
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for RoyaltyTarget {
        const MIN_SERIALIZED_SIZE: usize =
            <::std::vec::Vec<u8>>::MIN_SERIALIZED_SIZE + <u8>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.address.serialized_size() + self.share.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            Ok(self.address._serialize_chained(dest)? + self.share._serialize_chained(dest)?)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    address: v0,
                    share: v1,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for RoyaltyTarget {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct Creator {
        pub address: ::std::vec::Vec<u8>,
        pub share: u8,
        pub verified: bool,
    }

    impl<'raw> ::core::convert::From<super::Creator<'raw>> for Creator {
        fn from(value: super::Creator) -> Self {
            Self {
                address: value.address.iter().map(|value| value).collect(),
                share: value.share,
                verified: value.verified,
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Creator {
        const MIN_SERIALIZED_SIZE: usize = <::std::vec::Vec<u8>>::MIN_SERIALIZED_SIZE
            + <u8>::MIN_SERIALIZED_SIZE
            + <bool>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.address.serialized_size()
                + self.share.serialized_size()
                + self.verified.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            Ok(self.address._serialize_chained(dest)?
                + self.share._serialize_chained(dest)?
                + self.verified._serialize_chained(dest)?)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    address: v0,
                    share: v1,
                    verified: v2,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Creator {}

    pub use super::Lifecycle;
}
