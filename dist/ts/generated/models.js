"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DigitalAssetTypes = void 0;
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           2.4.5
//
//
//       bebopc source:
//           https://github.com/RainwayApp/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
const bebop_1 = require("bebop");
var DigitalAssetTypes;
(function (DigitalAssetTypes) {
    let Interface;
    (function (Interface) {
        Interface[Interface["Unknown"] = 0] = "Unknown";
        Interface[Interface["NFTv1"] = 1] = "NFTv1";
        Interface[Interface["NFT"] = 2] = "NFT";
        Interface[Interface["NFTPrintable"] = 3] = "NFTPrintable";
        Interface[Interface["NFTGroup"] = 4] = "NFTGroup";
        Interface[Interface["FungibleAsset"] = 5] = "FungibleAsset";
        Interface[Interface["IdentityAsset"] = 6] = "IdentityAsset";
    })(Interface = DigitalAssetTypes.Interface || (DigitalAssetTypes.Interface = {}));
    let ModuleType;
    (function (ModuleType) {
        ModuleType[ModuleType["Invalid"] = 0] = "Invalid";
        ModuleType[ModuleType["Signature"] = 1] = "Signature";
        ModuleType[ModuleType["Ownership"] = 2] = "Ownership";
        ModuleType[ModuleType["Creators"] = 3] = "Creators";
        ModuleType[ModuleType["Data"] = 4] = "Data";
        ModuleType[ModuleType["Royalty"] = 5] = "Royalty";
        ModuleType[ModuleType["Rights"] = 6] = "Rights";
        ModuleType[ModuleType["Extension"] = 7] = "Extension";
        ModuleType[ModuleType["Governance"] = 8] = "Governance";
    })(ModuleType = DigitalAssetTypes.ModuleType || (DigitalAssetTypes.ModuleType = {}));
    DigitalAssetTypes.CreatorsData = {
        discriminator: 1,
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            {
                const length0 = message.creators.length;
                view.writeUint32(length0);
                for (let i0 = 0; i0 < length0; i0++) {
                    DigitalAssetTypes.Creator.encodeInto(message.creators[i0], view);
                }
            }
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let field0;
            {
                let length0 = view.readUint32();
                field0 = new Array(length0);
                for (let i0 = 0; i0 < length0; i0++) {
                    let x0;
                    x0 = DigitalAssetTypes.Creator.readFrom(view);
                    field0[i0] = x0;
                }
            }
            let message = {
                creators: field0,
            };
            return message;
        },
    };
    DigitalAssetTypes.OwnershipData = {
        discriminator: 2,
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            view.writeByte(message.model);
            view.writeBytes(message.owner);
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let field0;
            field0 = view.readByte();
            let field1;
            field1 = view.readBytes();
            let message = {
                model: field0,
                owner: field1,
            };
            return message;
        },
    };
    DigitalAssetTypes.RoyaltyData = {
        discriminator: 3,
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            view.writeUint16(message.royalty);
            view.writeByte(message.model);
            {
                const length0 = message.target.length;
                view.writeUint32(length0);
                for (let i0 = 0; i0 < length0; i0++) {
                    DigitalAssetTypes.RoyaltyTarget.encodeInto(message.target[i0], view);
                }
            }
            view.writeByte(Number(message.locked));
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let field0;
            field0 = view.readUint16();
            let field1;
            field1 = view.readByte();
            let field2;
            {
                let length0 = view.readUint32();
                field2 = new Array(length0);
                for (let i0 = 0; i0 < length0; i0++) {
                    let x0;
                    x0 = DigitalAssetTypes.RoyaltyTarget.readFrom(view);
                    field2[i0] = x0;
                }
            }
            let field3;
            field3 = !!view.readByte();
            let message = {
                royalty: field0,
                model: field1,
                target: field2,
                locked: field3,
            };
            return message;
        },
    };
    DigitalAssetTypes.GovernanceData = {
        discriminator: 4,
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            {
                const length0 = message.authorities.length;
                view.writeUint32(length0);
                for (let i0 = 0; i0 < length0; i0++) {
                    DigitalAssetTypes.Authority.encodeInto(message.authorities[i0], view);
                }
            }
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let field0;
            {
                let length0 = view.readUint32();
                field0 = new Array(length0);
                for (let i0 = 0; i0 < length0; i0++) {
                    let x0;
                    x0 = DigitalAssetTypes.Authority.readFrom(view);
                    field0[i0] = x0;
                }
            }
            let message = {
                authorities: field0,
            };
            return message;
        },
    };
    DigitalAssetTypes.Data = {
        discriminator: 5,
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            view.writeUint32(message.layout.size);
            for (const [k0, v0] of message.layout) {
                view.writeByte(k0);
                DigitalAssetTypes.DataItem.encodeInto(v0, view);
            }
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let field0;
            {
                let length0 = view.readUint32();
                field0 = new Map();
                for (let i0 = 0; i0 < length0; i0++) {
                    let k0;
                    let v0;
                    k0 = view.readByte();
                    v0 = DigitalAssetTypes.DataItem.readFrom(view);
                    field0.set(k0, v0);
                }
            }
            let message = {
                layout: field0,
            };
            return message;
        },
    };
    DigitalAssetTypes.ModuleData = {
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            const pos = view.reserveMessageLength();
            const start = view.length + 1;
            view.writeByte(message.discriminator);
            switch (message.discriminator) {
                case 1:
                    DigitalAssetTypes.CreatorsData.encodeInto(message.value, view);
                    break;
                case 2:
                    DigitalAssetTypes.OwnershipData.encodeInto(message.value, view);
                    break;
                case 3:
                    DigitalAssetTypes.RoyaltyData.encodeInto(message.value, view);
                    break;
                case 4:
                    DigitalAssetTypes.GovernanceData.encodeInto(message.value, view);
                    break;
                case 5:
                    DigitalAssetTypes.Data.encodeInto(message.value, view);
                    break;
            }
            const end = view.length;
            view.fillMessageLength(pos, end - start);
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            const length = view.readMessageLength();
            const end = view.index + 1 + length;
            switch (view.readByte()) {
                case 1:
                    return { discriminator: 1, value: DigitalAssetTypes.CreatorsData.readFrom(view) };
                case 2:
                    return { discriminator: 2, value: DigitalAssetTypes.OwnershipData.readFrom(view) };
                case 3:
                    return { discriminator: 3, value: DigitalAssetTypes.RoyaltyData.readFrom(view) };
                case 4:
                    return { discriminator: 4, value: DigitalAssetTypes.GovernanceData.readFrom(view) };
                case 5:
                    return { discriminator: 5, value: DigitalAssetTypes.Data.readFrom(view) };
                default:
                    view.index = end;
                    throw new bebop_1.BebopRuntimeError("Unrecognized discriminator while decoding ModuleData");
            }
        },
    };
    let Encoding;
    (function (Encoding) {
        Encoding[Encoding["Invalid"] = 0] = "Invalid";
        Encoding[Encoding["Borsh"] = 1] = "Borsh";
        Encoding[Encoding["Bincode"] = 2] = "Bincode";
    })(Encoding = DigitalAssetTypes.Encoding || (DigitalAssetTypes.Encoding = {}));
    DigitalAssetTypes.String = {
        discriminator: 1,
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            const pos = view.reserveMessageLength();
            const start = view.length;
            if (message.value != null) {
                view.writeByte(1);
                view.writeString(message.value);
            }
            view.writeByte(0);
            const end = view.length;
            view.fillMessageLength(pos, end - start);
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let message = {};
            const length = view.readMessageLength();
            const end = view.index + length;
            while (true) {
                switch (view.readByte()) {
                    case 0:
                        return message;
                    case 1:
                        message.value = view.readString();
                        break;
                    default:
                        view.index = end;
                        return message;
                }
            }
        },
    };
    DigitalAssetTypes.Int = {
        discriminator: 2,
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            const pos = view.reserveMessageLength();
            const start = view.length;
            if (message.value != null) {
                view.writeByte(1);
                view.writeInt32(message.value);
            }
            view.writeByte(0);
            const end = view.length;
            view.fillMessageLength(pos, end - start);
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let message = {};
            const length = view.readMessageLength();
            const end = view.index + length;
            while (true) {
                switch (view.readByte()) {
                    case 0:
                        return message;
                    case 1:
                        message.value = view.readInt32();
                        break;
                    default:
                        view.index = end;
                        return message;
                }
            }
        },
    };
    DigitalAssetTypes.BigInt = {
        discriminator: 3,
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            const pos = view.reserveMessageLength();
            const start = view.length;
            if (message.value != null) {
                view.writeByte(1);
                view.writeInt64(message.value);
            }
            view.writeByte(0);
            const end = view.length;
            view.fillMessageLength(pos, end - start);
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let message = {};
            const length = view.readMessageLength();
            const end = view.index + length;
            while (true) {
                switch (view.readByte()) {
                    case 0:
                        return message;
                    case 1:
                        message.value = view.readInt64();
                        break;
                    default:
                        view.index = end;
                        return message;
                }
            }
        },
    };
    DigitalAssetTypes.Bytes = {
        discriminator: 4,
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            view.writeByte(message.encoding);
            view.writeBytes(message.raw);
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let field0;
            field0 = view.readByte();
            let field1;
            field1 = view.readBytes();
            let message = {
                encoding: field0,
                raw: field1,
            };
            return message;
        },
    };
    DigitalAssetTypes.DataItemValue = {
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            const pos = view.reserveMessageLength();
            const start = view.length + 1;
            view.writeByte(message.discriminator);
            switch (message.discriminator) {
                case 1:
                    DigitalAssetTypes.String.encodeInto(message.value, view);
                    break;
                case 2:
                    DigitalAssetTypes.Int.encodeInto(message.value, view);
                    break;
                case 3:
                    DigitalAssetTypes.BigInt.encodeInto(message.value, view);
                    break;
                case 4:
                    DigitalAssetTypes.Bytes.encodeInto(message.value, view);
                    break;
            }
            const end = view.length;
            view.fillMessageLength(pos, end - start);
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            const length = view.readMessageLength();
            const end = view.index + 1 + length;
            switch (view.readByte()) {
                case 1:
                    return { discriminator: 1, value: DigitalAssetTypes.String.readFrom(view) };
                case 2:
                    return { discriminator: 2, value: DigitalAssetTypes.Int.readFrom(view) };
                case 3:
                    return { discriminator: 3, value: DigitalAssetTypes.BigInt.readFrom(view) };
                case 4:
                    return { discriminator: 4, value: DigitalAssetTypes.Bytes.readFrom(view) };
                default:
                    view.index = end;
                    throw new bebop_1.BebopRuntimeError("Unrecognized discriminator while decoding DataItemValue");
            }
        },
    };
    DigitalAssetTypes.DataItem = {
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            view.writeString(message.key);
            DigitalAssetTypes.DataItemValue.encodeInto(message.value, view);
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let field0;
            field0 = view.readString();
            let field1;
            field1 = DigitalAssetTypes.DataItemValue.readFrom(view);
            let message = {
                key: field0,
                value: field1,
            };
            return message;
        },
    };
    DigitalAssetTypes.BlobContainer = {
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            view.writeUint32(message.blobs.size);
            for (const [k0, v0] of message.blobs) {
                view.writeByte(k0);
                DigitalAssetTypes.ModuleData.encodeInto(v0, view);
            }
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let field0;
            {
                let length0 = view.readUint32();
                field0 = new Map();
                for (let i0 = 0; i0 < length0; i0++) {
                    let k0;
                    let v0;
                    k0 = view.readByte();
                    v0 = DigitalAssetTypes.ModuleData.readFrom(view);
                    field0.set(k0, v0);
                }
            }
            let message = {
                blobs: field0,
            };
            return message;
        },
    };
    DigitalAssetTypes.Authority = {
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            {
                const length0 = message.scopes.length;
                view.writeUint32(length0);
                for (let i0 = 0; i0 < length0; i0++) {
                    view.writeString(message.scopes[i0]);
                }
            }
            view.writeBytes(message.address);
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let field0;
            {
                let length0 = view.readUint32();
                field0 = new Array(length0);
                for (let i0 = 0; i0 < length0; i0++) {
                    let x0;
                    x0 = view.readString();
                    field0[i0] = x0;
                }
            }
            let field1;
            field1 = view.readBytes();
            let message = {
                scopes: field0,
                address: field1,
            };
            return message;
        },
    };
    DigitalAssetTypes.Action = {
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            view.writeByte(message.standard);
            DigitalAssetTypes.ActionData.encodeInto(message.data, view);
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let field0;
            field0 = view.readByte();
            let field1;
            field1 = DigitalAssetTypes.ActionData.readFrom(view);
            let message = {
                standard: field0,
                data: field1,
            };
            return message;
        },
    };
    DigitalAssetTypes.CreateIdentityV1 = {
        discriminator: 1,
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            const pos = view.reserveMessageLength();
            const start = view.length;
            if (message.uri != null) {
                view.writeByte(1);
                view.writeString(message.uri);
            }
            view.writeByte(0);
            const end = view.length;
            view.fillMessageLength(pos, end - start);
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let message = {};
            const length = view.readMessageLength();
            const end = view.index + length;
            while (true) {
                switch (view.readByte()) {
                    case 0:
                        return message;
                    case 1:
                        message.uri = view.readString();
                        break;
                    default:
                        view.index = end;
                        return message;
                }
            }
        },
    };
    DigitalAssetTypes.CreateAssetV1 = {
        discriminator: 2,
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            const pos = view.reserveMessageLength();
            const start = view.length;
            if (message.uri != null) {
                view.writeByte(1);
                view.writeString(message.uri);
            }
            if (message.ownershipModel != null) {
                view.writeByte(2);
                view.writeByte(message.ownershipModel);
            }
            if (message.royaltyModel != null) {
                view.writeByte(3);
                view.writeByte(message.royaltyModel);
            }
            if (message.royalty != null) {
                view.writeByte(4);
                view.writeUint16(message.royalty);
            }
            if (message.dataSchema != null) {
                view.writeByte(5);
                view.writeByte(message.dataSchema);
            }
            if (message.creatorShares != null) {
                view.writeByte(6);
                view.writeBytes(message.creatorShares);
            }
            if (message.royaltyTarget != null) {
                view.writeByte(7);
                {
                    const length0 = message.royaltyTarget.length;
                    view.writeUint32(length0);
                    for (let i0 = 0; i0 < length0; i0++) {
                        DigitalAssetTypes.RoyaltyTarget.encodeInto(message.royaltyTarget[i0], view);
                    }
                }
            }
            if (message.authorities != null) {
                view.writeByte(8);
                {
                    const length0 = message.authorities.length;
                    view.writeUint32(length0);
                    for (let i0 = 0; i0 < length0; i0++) {
                        DigitalAssetTypes.Authority.encodeInto(message.authorities[i0], view);
                    }
                }
            }
            if (message.uuid != null) {
                view.writeByte(9);
                view.writeGuid(message.uuid);
            }
            view.writeByte(0);
            const end = view.length;
            view.fillMessageLength(pos, end - start);
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let message = {};
            const length = view.readMessageLength();
            const end = view.index + length;
            while (true) {
                switch (view.readByte()) {
                    case 0:
                        return message;
                    case 1:
                        message.uri = view.readString();
                        break;
                    case 2:
                        message.ownershipModel = view.readByte();
                        break;
                    case 3:
                        message.royaltyModel = view.readByte();
                        break;
                    case 4:
                        message.royalty = view.readUint16();
                        break;
                    case 5:
                        message.dataSchema = view.readByte();
                        break;
                    case 6:
                        message.creatorShares = view.readBytes();
                        break;
                    case 7:
                        {
                            let length0 = view.readUint32();
                            message.royaltyTarget = new Array(length0);
                            for (let i0 = 0; i0 < length0; i0++) {
                                let x0;
                                x0 = DigitalAssetTypes.RoyaltyTarget.readFrom(view);
                                message.royaltyTarget[i0] = x0;
                            }
                        }
                        break;
                    case 8:
                        {
                            let length0 = view.readUint32();
                            message.authorities = new Array(length0);
                            for (let i0 = 0; i0 < length0; i0++) {
                                let x0;
                                x0 = DigitalAssetTypes.Authority.readFrom(view);
                                message.authorities[i0] = x0;
                            }
                        }
                        break;
                    case 9:
                        message.uuid = view.readGuid();
                        break;
                    default:
                        view.index = end;
                        return message;
                }
            }
        },
    };
    DigitalAssetTypes.UpdateAssetV1 = {
        discriminator: 3,
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            const pos = view.reserveMessageLength();
            const start = view.length;
            if (message.msg != null) {
                view.writeByte(1);
                view.writeString(message.msg);
            }
            view.writeByte(0);
            const end = view.length;
            view.fillMessageLength(pos, end - start);
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let message = {};
            const length = view.readMessageLength();
            const end = view.index + length;
            while (true) {
                switch (view.readByte()) {
                    case 0:
                        return message;
                    case 1:
                        message.msg = view.readString();
                        break;
                    default:
                        view.index = end;
                        return message;
                }
            }
        },
    };
    DigitalAssetTypes.ActionData = {
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            const pos = view.reserveMessageLength();
            const start = view.length + 1;
            view.writeByte(message.discriminator);
            switch (message.discriminator) {
                case 1:
                    DigitalAssetTypes.CreateIdentityV1.encodeInto(message.value, view);
                    break;
                case 2:
                    DigitalAssetTypes.CreateAssetV1.encodeInto(message.value, view);
                    break;
                case 3:
                    DigitalAssetTypes.UpdateAssetV1.encodeInto(message.value, view);
                    break;
            }
            const end = view.length;
            view.fillMessageLength(pos, end - start);
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            const length = view.readMessageLength();
            const end = view.index + 1 + length;
            switch (view.readByte()) {
                case 1:
                    return { discriminator: 1, value: DigitalAssetTypes.CreateIdentityV1.readFrom(view) };
                case 2:
                    return { discriminator: 2, value: DigitalAssetTypes.CreateAssetV1.readFrom(view) };
                case 3:
                    return { discriminator: 3, value: DigitalAssetTypes.UpdateAssetV1.readFrom(view) };
                default:
                    view.index = end;
                    throw new bebop_1.BebopRuntimeError("Unrecognized discriminator while decoding ActionData");
            }
        },
    };
    DigitalAssetTypes.MAX_MODULES = 10;
    let OwnershipModel;
    (function (OwnershipModel) {
        OwnershipModel[OwnershipModel["Invalid"] = 0] = "Invalid";
        OwnershipModel[OwnershipModel["Single"] = 1] = "Single";
        OwnershipModel[OwnershipModel["Token"] = 2] = "Token";
    })(OwnershipModel = DigitalAssetTypes.OwnershipModel || (DigitalAssetTypes.OwnershipModel = {}));
    let RoyaltyModel;
    (function (RoyaltyModel) {
        RoyaltyModel[RoyaltyModel["Invalid"] = 0] = "Invalid";
        RoyaltyModel[RoyaltyModel["Address"] = 1] = "Address";
        RoyaltyModel[RoyaltyModel["Fanout"] = 2] = "Fanout";
        RoyaltyModel[RoyaltyModel["Creators"] = 3] = "Creators";
    })(RoyaltyModel = DigitalAssetTypes.RoyaltyModel || (DigitalAssetTypes.RoyaltyModel = {}));
    DigitalAssetTypes.RoyaltyTarget = {
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            view.writeBytes(message.address);
            view.writeByte(message.share);
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let field0;
            field0 = view.readBytes();
            let field1;
            field1 = view.readByte();
            let message = {
                address: field0,
                share: field1,
            };
            return message;
        },
    };
    DigitalAssetTypes.Creator = {
        encode(message) {
            const view = bebop_1.BebopView.getInstance();
            view.startWriting();
            this.encodeInto(message, view);
            return view.toArray();
        },
        encodeInto(message, view) {
            const before = view.length;
            view.writeBytes(message.address);
            view.writeByte(message.share);
            view.writeByte(Number(message.verified));
            const after = view.length;
            return after - before;
        },
        decode(buffer) {
            const view = bebop_1.BebopView.getInstance();
            view.startReading(buffer);
            return this.readFrom(view);
        },
        readFrom(view) {
            let field0;
            field0 = view.readBytes();
            let field1;
            field1 = view.readByte();
            let field2;
            field2 = !!view.readByte();
            let message = {
                address: field0,
                share: field1,
                verified: field2,
            };
            return message;
        },
    };
    let Lifecycle;
    (function (Lifecycle) {
        Lifecycle[Lifecycle["Invalid"] = 0] = "Invalid";
        Lifecycle[Lifecycle["Create"] = 1] = "Create";
        Lifecycle[Lifecycle["Transfer"] = 2] = "Transfer";
        Lifecycle[Lifecycle["Destroy"] = 3] = "Destroy";
        Lifecycle[Lifecycle["Update"] = 4] = "Update";
        Lifecycle[Lifecycle["Freeze"] = 5] = "Freeze";
        Lifecycle[Lifecycle["Thaw"] = 6] = "Thaw";
        Lifecycle[Lifecycle["Split"] = 7] = "Split";
        Lifecycle[Lifecycle["Combine"] = 8] = "Combine";
        Lifecycle[Lifecycle["SupplyIncrease"] = 9] = "SupplyIncrease";
        Lifecycle[Lifecycle["SupplyDecrease"] = 10] = "SupplyDecrease";
        Lifecycle[Lifecycle["ActivateExtension"] = 11] = "ActivateExtension";
        Lifecycle[Lifecycle["DeactivateExtension"] = 12] = "DeactivateExtension";
    })(Lifecycle = DigitalAssetTypes.Lifecycle || (DigitalAssetTypes.Lifecycle = {}));
    let JsonDataSchema;
    (function (JsonDataSchema) {
        JsonDataSchema[JsonDataSchema["Invalid"] = 0] = "Invalid";
        JsonDataSchema[JsonDataSchema["Core"] = 1] = "Core";
        JsonDataSchema[JsonDataSchema["MultiMedia"] = 2] = "MultiMedia";
        JsonDataSchema[JsonDataSchema["SimpleImage"] = 3] = "SimpleImage";
        JsonDataSchema[JsonDataSchema["SimpleAudio"] = 4] = "SimpleAudio";
        JsonDataSchema[JsonDataSchema["Simple3d"] = 5] = "Simple3d";
        JsonDataSchema[JsonDataSchema["SimpleText"] = 6] = "SimpleText";
        JsonDataSchema[JsonDataSchema["MusicRecording"] = 7] = "MusicRecording";
    })(JsonDataSchema = DigitalAssetTypes.JsonDataSchema || (DigitalAssetTypes.JsonDataSchema = {}));
})(DigitalAssetTypes = exports.DigitalAssetTypes || (exports.DigitalAssetTypes = {}));
//# sourceMappingURL=models.js.map