//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           2.4.5
//
//
//       bebopc source:
//           https://github.com/RainwayApp/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError } from "bebop";

export namespace DigitalAssetTypes {
  export enum Interface {
    Unknown = 0,
    NFTv1 = 1,
    NFT = 2,
    NFTPrintable = 3,
    NFTGroup = 4,
    FungibleAsset = 5,
    IdentityAsset = 6,
  }

  export enum ModuleType {
    Invalid = 0,
    Signature = 1,
    Ownership = 2,
    Creators = 3,
    Data = 4,
    Royalty = 5,
    Rights = 6,
    Extension = 7,
    Governance = 8,
  }

  export interface ICreatorsData {
    creators: Array<ICreator>;
  }

  export const CreatorsData = {
    discriminator: 1 as 1,
    encode(message: ICreatorsData): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: ICreatorsData, view: BebopView): number {
      const before = view.length;
        {
          const length0 = message.creators.length;
          view.writeUint32(length0);
          for (let i0 = 0; i0 < length0; i0++) {
            Creator.encodeInto(message.creators[i0], view)
          }
        }
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): ICreatorsData {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): ICreatorsData {
      let field0: Array<ICreator>;
      {
        let length0 = view.readUint32();
        field0 = new Array<ICreator>(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          let x0: ICreator;
          x0 = Creator.readFrom(view);
          field0[i0] = x0;
        }
      }
      let message: ICreatorsData = {
        creators: field0,
      };
      return message;
    },
  };

  export interface IOwnershipData {
    model: OwnershipModel;
    owner: Uint8Array;
  }

  export const OwnershipData = {
    discriminator: 2 as 2,
    encode(message: IOwnershipData): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IOwnershipData, view: BebopView): number {
      const before = view.length;
        view.writeByte(message.model);
        view.writeBytes(message.owner);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IOwnershipData {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IOwnershipData {
      let field0: OwnershipModel;
      field0 = view.readByte() as OwnershipModel;
      let field1: Uint8Array;
      field1 = view.readBytes();
      let message: IOwnershipData = {
        model: field0,
        owner: field1,
      };
      return message;
    },
  };

  export interface IRoyaltyData {
    royalty: number;
    model: RoyaltyModel;
    target: Array<IRoyaltyTarget>;
    locked: boolean;
  }

  export const RoyaltyData = {
    discriminator: 3 as 3,
    encode(message: IRoyaltyData): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IRoyaltyData, view: BebopView): number {
      const before = view.length;
        view.writeUint16(message.royalty);
        view.writeByte(message.model);
        {
          const length0 = message.target.length;
          view.writeUint32(length0);
          for (let i0 = 0; i0 < length0; i0++) {
            RoyaltyTarget.encodeInto(message.target[i0], view)
          }
        }
        view.writeByte(Number(message.locked));
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IRoyaltyData {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IRoyaltyData {
      let field0: number;
      field0 = view.readUint16();
      let field1: RoyaltyModel;
      field1 = view.readByte() as RoyaltyModel;
      let field2: Array<IRoyaltyTarget>;
      {
        let length0 = view.readUint32();
        field2 = new Array<IRoyaltyTarget>(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          let x0: IRoyaltyTarget;
          x0 = RoyaltyTarget.readFrom(view);
          field2[i0] = x0;
        }
      }
      let field3: boolean;
      field3 = !!view.readByte();
      let message: IRoyaltyData = {
        royalty: field0,
        model: field1,
        target: field2,
        locked: field3,
      };
      return message;
    },
  };

  export interface IGovernanceData {
    authorities: Array<IAuthority>;
  }

  export const GovernanceData = {
    discriminator: 4 as 4,
    encode(message: IGovernanceData): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IGovernanceData, view: BebopView): number {
      const before = view.length;
        {
          const length0 = message.authorities.length;
          view.writeUint32(length0);
          for (let i0 = 0; i0 < length0; i0++) {
            Authority.encodeInto(message.authorities[i0], view)
          }
        }
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IGovernanceData {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IGovernanceData {
      let field0: Array<IAuthority>;
      {
        let length0 = view.readUint32();
        field0 = new Array<IAuthority>(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          let x0: IAuthority;
          x0 = Authority.readFrom(view);
          field0[i0] = x0;
        }
      }
      let message: IGovernanceData = {
        authorities: field0,
      };
      return message;
    },
  };

  export interface IData {
    layout: Map<number, IDataItem>;
  }

  export const Data = {
    discriminator: 5 as 5,
    encode(message: IData): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IData, view: BebopView): number {
      const before = view.length;
        view.writeUint32(message.layout.size);
        for (const [k0, v0] of message.layout) {
          view.writeByte(k0);
          DataItem.encodeInto(v0, view)
        }
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IData {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IData {
      let field0: Map<number, IDataItem>;
      {
        let length0 = view.readUint32();
        field0 = new Map<number, IDataItem>();
        for (let i0 = 0; i0 < length0; i0++) {
          let k0: number;
          let v0: IDataItem;
          k0 = view.readByte();
          v0 = DataItem.readFrom(view);
          field0.set(k0, v0);
        }
      }
      let message: IData = {
        layout: field0,
      };
      return message;
    },
  };

  export type IModuleData
    = { discriminator: 1, value: ICreatorsData }
    | { discriminator: 2, value: IOwnershipData }
    | { discriminator: 3, value: IRoyaltyData }
    | { discriminator: 4, value: IGovernanceData }
    | { discriminator: 5, value: IData };

  export const ModuleData = {
    encode(message: IModuleData): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IModuleData, view: BebopView): number {
      const before = view.length;
        const pos = view.reserveMessageLength();
        const start = view.length + 1;
        view.writeByte(message.discriminator);
        switch (message.discriminator) {
          case 1:
            CreatorsData.encodeInto(message.value, view);
            break;
          case 2:
            OwnershipData.encodeInto(message.value, view);
            break;
          case 3:
            RoyaltyData.encodeInto(message.value, view);
            break;
          case 4:
            GovernanceData.encodeInto(message.value, view);
            break;
          case 5:
            Data.encodeInto(message.value, view);
            break;
        }
        const end = view.length;
        view.fillMessageLength(pos, end - start);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IModuleData {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IModuleData {
      const length = view.readMessageLength();
      const end = view.index + 1 + length;
      switch (view.readByte()) {
        case 1:
          return { discriminator: 1, value: CreatorsData.readFrom(view) };
        case 2:
          return { discriminator: 2, value: OwnershipData.readFrom(view) };
        case 3:
          return { discriminator: 3, value: RoyaltyData.readFrom(view) };
        case 4:
          return { discriminator: 4, value: GovernanceData.readFrom(view) };
        case 5:
          return { discriminator: 5, value: Data.readFrom(view) };
        default:
          view.index = end;
          throw new BebopRuntimeError("Unrecognized discriminator while decoding ModuleData");
      }
    },
  };

  export enum Encoding {
    Invalid = 0,
    Borsh = 1,
    Bincode = 2,
  }

  export interface IString {
    value?: string;
  }

  export const String = {
    discriminator: 1 as 1,
    encode(message: IString): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IString, view: BebopView): number {
      const before = view.length;
        const pos = view.reserveMessageLength();
        const start = view.length;
        if (message.value != null) {
          view.writeByte(1);
          view.writeString(message.value);
        }
        view.writeByte(0);
        const end = view.length;
        view.fillMessageLength(pos, end - start);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IString {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IString {
      let message: IString = {};
      const length = view.readMessageLength();
      const end = view.index + length;
      while (true) {
        switch (view.readByte()) {
          case 0:
            return message;

          case 1:
            message.value = view.readString();
            break;

          default:
            view.index = end;
            return message;
        }
      }
    },
  };

  export interface IInt {
    value?: number;
  }

  export const Int = {
    discriminator: 2 as 2,
    encode(message: IInt): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IInt, view: BebopView): number {
      const before = view.length;
        const pos = view.reserveMessageLength();
        const start = view.length;
        if (message.value != null) {
          view.writeByte(1);
          view.writeInt32(message.value);
        }
        view.writeByte(0);
        const end = view.length;
        view.fillMessageLength(pos, end - start);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IInt {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IInt {
      let message: IInt = {};
      const length = view.readMessageLength();
      const end = view.index + length;
      while (true) {
        switch (view.readByte()) {
          case 0:
            return message;

          case 1:
            message.value = view.readInt32();
            break;

          default:
            view.index = end;
            return message;
        }
      }
    },
  };

  export interface IBigInt {
    value?: bigint;
  }

  export const BigInt = {
    discriminator: 3 as 3,
    encode(message: IBigInt): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IBigInt, view: BebopView): number {
      const before = view.length;
        const pos = view.reserveMessageLength();
        const start = view.length;
        if (message.value != null) {
          view.writeByte(1);
          view.writeInt64(message.value);
        }
        view.writeByte(0);
        const end = view.length;
        view.fillMessageLength(pos, end - start);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IBigInt {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IBigInt {
      let message: IBigInt = {};
      const length = view.readMessageLength();
      const end = view.index + length;
      while (true) {
        switch (view.readByte()) {
          case 0:
            return message;

          case 1:
            message.value = view.readInt64();
            break;

          default:
            view.index = end;
            return message;
        }
      }
    },
  };

  export interface IBytes {
    encoding: Encoding;
    raw: Uint8Array;
  }

  export const Bytes = {
    discriminator: 4 as 4,
    encode(message: IBytes): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IBytes, view: BebopView): number {
      const before = view.length;
        view.writeByte(message.encoding);
        view.writeBytes(message.raw);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IBytes {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IBytes {
      let field0: Encoding;
      field0 = view.readByte() as Encoding;
      let field1: Uint8Array;
      field1 = view.readBytes();
      let message: IBytes = {
        encoding: field0,
        raw: field1,
      };
      return message;
    },
  };

  export type IDataItemValue
    = { discriminator: 1, value: IString }
    | { discriminator: 2, value: IInt }
    | { discriminator: 3, value: IBigInt }
    | { discriminator: 4, value: IBytes };

  export const DataItemValue = {
    encode(message: IDataItemValue): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IDataItemValue, view: BebopView): number {
      const before = view.length;
        const pos = view.reserveMessageLength();
        const start = view.length + 1;
        view.writeByte(message.discriminator);
        switch (message.discriminator) {
          case 1:
            String.encodeInto(message.value, view);
            break;
          case 2:
            Int.encodeInto(message.value, view);
            break;
          case 3:
            BigInt.encodeInto(message.value, view);
            break;
          case 4:
            Bytes.encodeInto(message.value, view);
            break;
        }
        const end = view.length;
        view.fillMessageLength(pos, end - start);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IDataItemValue {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IDataItemValue {
      const length = view.readMessageLength();
      const end = view.index + 1 + length;
      switch (view.readByte()) {
        case 1:
          return { discriminator: 1, value: String.readFrom(view) };
        case 2:
          return { discriminator: 2, value: Int.readFrom(view) };
        case 3:
          return { discriminator: 3, value: BigInt.readFrom(view) };
        case 4:
          return { discriminator: 4, value: Bytes.readFrom(view) };
        default:
          view.index = end;
          throw new BebopRuntimeError("Unrecognized discriminator while decoding DataItemValue");
      }
    },
  };

  export interface IDataItem {
    key: string;
    value: IDataItemValue;
  }

  export const DataItem = {
    encode(message: IDataItem): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IDataItem, view: BebopView): number {
      const before = view.length;
        view.writeString(message.key);
        DataItemValue.encodeInto(message.value, view)
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IDataItem {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IDataItem {
      let field0: string;
      field0 = view.readString();
      let field1: IDataItemValue;
      field1 = DataItemValue.readFrom(view);
      let message: IDataItem = {
        key: field0,
        value: field1,
      };
      return message;
    },
  };

  export interface IBlobContainer {
    blobs: Map<number, IModuleData>;
  }

  export const BlobContainer = {
    encode(message: IBlobContainer): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IBlobContainer, view: BebopView): number {
      const before = view.length;
        view.writeUint32(message.blobs.size);
        for (const [k0, v0] of message.blobs) {
          view.writeByte(k0);
          ModuleData.encodeInto(v0, view)
        }
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IBlobContainer {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IBlobContainer {
      let field0: Map<number, IModuleData>;
      {
        let length0 = view.readUint32();
        field0 = new Map<number, IModuleData>();
        for (let i0 = 0; i0 < length0; i0++) {
          let k0: number;
          let v0: IModuleData;
          k0 = view.readByte();
          v0 = ModuleData.readFrom(view);
          field0.set(k0, v0);
        }
      }
      let message: IBlobContainer = {
        blobs: field0,
      };
      return message;
    },
  };

  export interface IAuthority {
    scopes: Array<string>;
    address: Uint8Array;
  }

  export const Authority = {
    encode(message: IAuthority): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IAuthority, view: BebopView): number {
      const before = view.length;
        {
          const length0 = message.scopes.length;
          view.writeUint32(length0);
          for (let i0 = 0; i0 < length0; i0++) {
            view.writeString(message.scopes[i0]);
          }
        }
        view.writeBytes(message.address);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IAuthority {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IAuthority {
      let field0: Array<string>;
      {
        let length0 = view.readUint32();
        field0 = new Array<string>(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          let x0: string;
          x0 = view.readString();
          field0[i0] = x0;
        }
      }
      let field1: Uint8Array;
      field1 = view.readBytes();
      let message: IAuthority = {
        scopes: field0,
        address: field1,
      };
      return message;
    },
  };

  export interface IAction {
    standard: Interface;
    data: IActionData;
  }

  export const Action = {
    encode(message: IAction): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IAction, view: BebopView): number {
      const before = view.length;
        view.writeByte(message.standard);
        ActionData.encodeInto(message.data, view)
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IAction {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IAction {
      let field0: Interface;
      field0 = view.readByte() as Interface;
      let field1: IActionData;
      field1 = ActionData.readFrom(view);
      let message: IAction = {
        standard: field0,
        data: field1,
      };
      return message;
    },
  };

  export interface ICreateIdentityV1 {
    uri?: string;
  }

  export const CreateIdentityV1 = {
    discriminator: 1 as 1,
    encode(message: ICreateIdentityV1): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: ICreateIdentityV1, view: BebopView): number {
      const before = view.length;
        const pos = view.reserveMessageLength();
        const start = view.length;
        if (message.uri != null) {
          view.writeByte(1);
          view.writeString(message.uri);
        }
        view.writeByte(0);
        const end = view.length;
        view.fillMessageLength(pos, end - start);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): ICreateIdentityV1 {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): ICreateIdentityV1 {
      let message: ICreateIdentityV1 = {};
      const length = view.readMessageLength();
      const end = view.index + length;
      while (true) {
        switch (view.readByte()) {
          case 0:
            return message;

          case 1:
            message.uri = view.readString();
            break;

          default:
            view.index = end;
            return message;
        }
      }
    },
  };

  export interface ICreateAssetV1 {
    uri?: string;
    ownershipModel?: OwnershipModel;
    royaltyModel?: RoyaltyModel;
    royalty?: number;
    dataSchema?: JsonDataSchema;
    creatorShares?: Uint8Array;
    royaltyTarget?: Array<IRoyaltyTarget>;
    authorities?: Array<IAuthority>;
    uuid?: string;
  }

  export const CreateAssetV1 = {
    discriminator: 2 as 2,
    encode(message: ICreateAssetV1): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: ICreateAssetV1, view: BebopView): number {
      const before = view.length;
        const pos = view.reserveMessageLength();
        const start = view.length;
        if (message.uri != null) {
          view.writeByte(1);
          view.writeString(message.uri);
        }
        if (message.ownershipModel != null) {
          view.writeByte(2);
          view.writeByte(message.ownershipModel);
        }
        if (message.royaltyModel != null) {
          view.writeByte(3);
          view.writeByte(message.royaltyModel);
        }
        if (message.royalty != null) {
          view.writeByte(4);
          view.writeUint16(message.royalty);
        }
        if (message.dataSchema != null) {
          view.writeByte(5);
          view.writeByte(message.dataSchema);
        }
        if (message.creatorShares != null) {
          view.writeByte(6);
          view.writeBytes(message.creatorShares);
        }
        if (message.royaltyTarget != null) {
          view.writeByte(7);
          {
          const length0 = message.royaltyTarget.length;
          view.writeUint32(length0);
          for (let i0 = 0; i0 < length0; i0++) {
            RoyaltyTarget.encodeInto(message.royaltyTarget[i0], view)
          }
        }
        }
        if (message.authorities != null) {
          view.writeByte(8);
          {
          const length0 = message.authorities.length;
          view.writeUint32(length0);
          for (let i0 = 0; i0 < length0; i0++) {
            Authority.encodeInto(message.authorities[i0], view)
          }
        }
        }
        if (message.uuid != null) {
          view.writeByte(9);
          view.writeGuid(message.uuid);
        }
        view.writeByte(0);
        const end = view.length;
        view.fillMessageLength(pos, end - start);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): ICreateAssetV1 {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): ICreateAssetV1 {
      let message: ICreateAssetV1 = {};
      const length = view.readMessageLength();
      const end = view.index + length;
      while (true) {
        switch (view.readByte()) {
          case 0:
            return message;

          case 1:
            message.uri = view.readString();
            break;

          case 2:
            message.ownershipModel = view.readByte() as OwnershipModel;
            break;

          case 3:
            message.royaltyModel = view.readByte() as RoyaltyModel;
            break;

          case 4:
            message.royalty = view.readUint16();
            break;

          case 5:
            message.dataSchema = view.readByte() as JsonDataSchema;
            break;

          case 6:
            message.creatorShares = view.readBytes();
            break;

          case 7:
            {
          let length0 = view.readUint32();
          message.royaltyTarget = new Array<IRoyaltyTarget>(length0);
          for (let i0 = 0; i0 < length0; i0++) {
            let x0: IRoyaltyTarget;
            x0 = RoyaltyTarget.readFrom(view);
            message.royaltyTarget[i0] = x0;
          }
        }
            break;

          case 8:
            {
          let length0 = view.readUint32();
          message.authorities = new Array<IAuthority>(length0);
          for (let i0 = 0; i0 < length0; i0++) {
            let x0: IAuthority;
            x0 = Authority.readFrom(view);
            message.authorities[i0] = x0;
          }
        }
            break;

          case 9:
            message.uuid = view.readGuid();
            break;

          default:
            view.index = end;
            return message;
        }
      }
    },
  };

  export interface IUpdateAssetV1 {
    msg?: string;
  }

  export const UpdateAssetV1 = {
    discriminator: 3 as 3,
    encode(message: IUpdateAssetV1): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IUpdateAssetV1, view: BebopView): number {
      const before = view.length;
        const pos = view.reserveMessageLength();
        const start = view.length;
        if (message.msg != null) {
          view.writeByte(1);
          view.writeString(message.msg);
        }
        view.writeByte(0);
        const end = view.length;
        view.fillMessageLength(pos, end - start);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IUpdateAssetV1 {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IUpdateAssetV1 {
      let message: IUpdateAssetV1 = {};
      const length = view.readMessageLength();
      const end = view.index + length;
      while (true) {
        switch (view.readByte()) {
          case 0:
            return message;

          case 1:
            message.msg = view.readString();
            break;

          default:
            view.index = end;
            return message;
        }
      }
    },
  };

  export type IActionData
    = { discriminator: 1, value: ICreateIdentityV1 }
    | { discriminator: 2, value: ICreateAssetV1 }
    | { discriminator: 3, value: IUpdateAssetV1 };

  export const ActionData = {
    encode(message: IActionData): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IActionData, view: BebopView): number {
      const before = view.length;
        const pos = view.reserveMessageLength();
        const start = view.length + 1;
        view.writeByte(message.discriminator);
        switch (message.discriminator) {
          case 1:
            CreateIdentityV1.encodeInto(message.value, view);
            break;
          case 2:
            CreateAssetV1.encodeInto(message.value, view);
            break;
          case 3:
            UpdateAssetV1.encodeInto(message.value, view);
            break;
        }
        const end = view.length;
        view.fillMessageLength(pos, end - start);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IActionData {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IActionData {
      const length = view.readMessageLength();
      const end = view.index + 1 + length;
      switch (view.readByte()) {
        case 1:
          return { discriminator: 1, value: CreateIdentityV1.readFrom(view) };
        case 2:
          return { discriminator: 2, value: CreateAssetV1.readFrom(view) };
        case 3:
          return { discriminator: 3, value: UpdateAssetV1.readFrom(view) };
        default:
          view.index = end;
          throw new BebopRuntimeError("Unrecognized discriminator while decoding ActionData");
      }
    },
  };

  export const MAX_MODULES: number = 10;

  export enum OwnershipModel {
    Invalid = 0,
    Single = 1,
    Token = 2,
  }

  export enum RoyaltyModel {
    Invalid = 0,
    Address = 1,
    Fanout = 2,
    Creators = 3,
  }

  export interface IRoyaltyTarget {
    address: Uint8Array;
    share: number;
  }

  export const RoyaltyTarget = {
    encode(message: IRoyaltyTarget): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IRoyaltyTarget, view: BebopView): number {
      const before = view.length;
        view.writeBytes(message.address);
        view.writeByte(message.share);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IRoyaltyTarget {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IRoyaltyTarget {
      let field0: Uint8Array;
      field0 = view.readBytes();
      let field1: number;
      field1 = view.readByte();
      let message: IRoyaltyTarget = {
        address: field0,
        share: field1,
      };
      return message;
    },
  };

  export interface ICreator {
    address: Uint8Array;
    share: number;
    verified: boolean;
  }

  export const Creator = {
    encode(message: ICreator): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: ICreator, view: BebopView): number {
      const before = view.length;
        view.writeBytes(message.address);
        view.writeByte(message.share);
        view.writeByte(Number(message.verified));
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): ICreator {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): ICreator {
      let field0: Uint8Array;
      field0 = view.readBytes();
      let field1: number;
      field1 = view.readByte();
      let field2: boolean;
      field2 = !!view.readByte();
      let message: ICreator = {
        address: field0,
        share: field1,
        verified: field2,
      };
      return message;
    },
  };

  export enum Lifecycle {
    Invalid = 0,
    Create = 1,
    Transfer = 2,
    Destroy = 3,
    Update = 4,
    Freeze = 5,
    Thaw = 6,
    Split = 7,
    Combine = 8,
    SupplyIncrease = 9,
    SupplyDecrease = 10,
    ActivateExtension = 11,
    DeactivateExtension = 12,
  }

  export enum JsonDataSchema {
    Invalid = 0,
    Core = 1,
    MultiMedia = 2,
    SimpleImage = 3,
    SimpleAudio = 4,
    Simple3d = 5,
    SimpleText = 6,
    MusicRecording = 7,
  }

}
