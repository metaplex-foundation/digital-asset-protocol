//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           2.4.2
//
//
//       bebopc source:
//           https://github.com/RainwayApp/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError } from "bebop";

export namespace DigitalAssetTypes {
  export enum Interface {
    Unknown = 0,
    NFTv1 = 1,
    NFT = 2,
    NFTPrintable = 3,
    NFTGroup = 4,
    FungibleAsset = 5,
    IdentityAsset = 6,
  }

  export enum ModuleType {
    Invalid = 0,
    Signature = 1,
    Ownership = 2,
    Creators = 3,
    Data = 4,
    Royalty = 5,
    Rights = 6,
    Extension = 7,
  }

  export interface ICreatorsData {
    creators: Array<ICreator>;
  }

  export const CreatorsData = {
    discriminator: 1 as 1,
    encode(message: ICreatorsData): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: ICreatorsData, view: BebopView): number {
      const before = view.length;
        {
          const length0 = message.creators.length;
          view.writeUint32(length0);
          for (let i0 = 0; i0 < length0; i0++) {
            Creator.encodeInto(message.creators[i0], view)
          }
        }
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): ICreatorsData {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): ICreatorsData {
      let field0: Array<ICreator>;
      {
        let length0 = view.readUint32();
        field0 = new Array<ICreator>(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          let x0: ICreator;
          x0 = Creator.readFrom(view);
          field0[i0] = x0;
        }
      }
      let message: ICreatorsData = {
        creators: field0,
      };
      return message;
    },
  };

  export interface IOwnershipData {
    model: OwnershipModel;
    owner: Uint8Array;
  }

  export const OwnershipData = {
    discriminator: 2 as 2,
    encode(message: IOwnershipData): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IOwnershipData, view: BebopView): number {
      const before = view.length;
        view.writeByte(message.model);
        view.writeBytes(message.owner);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IOwnershipData {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IOwnershipData {
      let field0: OwnershipModel;
      field0 = view.readByte() as OwnershipModel;
      let field1: Uint8Array;
      field1 = view.readBytes();
      let message: IOwnershipData = {
        model: field0,
        owner: field1,
      };
      return message;
    },
  };

  export interface IRoyaltyData {
    royaltyPercent: number;
    model: RoyaltyModel;
    target: Array<IRoyaltyTarget>;
    locked: boolean;
  }

  export const RoyaltyData = {
    discriminator: 3 as 3,
    encode(message: IRoyaltyData): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IRoyaltyData, view: BebopView): number {
      const before = view.length;
        view.writeByte(message.royaltyPercent);
        view.writeByte(message.model);
        {
          const length0 = message.target.length;
          view.writeUint32(length0);
          for (let i0 = 0; i0 < length0; i0++) {
            RoyaltyTarget.encodeInto(message.target[i0], view)
          }
        }
        view.writeByte(Number(message.locked));
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IRoyaltyData {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IRoyaltyData {
      let field0: number;
      field0 = view.readByte();
      let field1: RoyaltyModel;
      field1 = view.readByte() as RoyaltyModel;
      let field2: Array<IRoyaltyTarget>;
      {
        let length0 = view.readUint32();
        field2 = new Array<IRoyaltyTarget>(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          let x0: IRoyaltyTarget;
          x0 = RoyaltyTarget.readFrom(view);
          field2[i0] = x0;
        }
      }
      let field3: boolean;
      field3 = !!view.readByte();
      let message: IRoyaltyData = {
        royaltyPercent: field0,
        model: field1,
        target: field2,
        locked: field3,
      };
      return message;
    },
  };

  export type IModuleData
    = { discriminator: 1, value: ICreatorsData }
    | { discriminator: 2, value: IOwnershipData }
    | { discriminator: 3, value: IRoyaltyData };

  export const ModuleData = {
    encode(message: IModuleData): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IModuleData, view: BebopView): number {
      const before = view.length;
        const pos = view.reserveMessageLength();
        const start = view.length + 1;
        view.writeByte(message.discriminator);
        switch (message.discriminator) {
          case 1:
            CreatorsData.encodeInto(message.value, view);
            break;
          case 2:
            OwnershipData.encodeInto(message.value, view);
            break;
          case 3:
            RoyaltyData.encodeInto(message.value, view);
            break;
        }
        const end = view.length;
        view.fillMessageLength(pos, end - start);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IModuleData {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IModuleData {
      const length = view.readMessageLength();
      const end = view.index + 1 + length;
      switch (view.readByte()) {
        case 1:
          return { discriminator: 1, value: CreatorsData.readFrom(view) };
        case 2:
          return { discriminator: 2, value: OwnershipData.readFrom(view) };
        case 3:
          return { discriminator: 3, value: RoyaltyData.readFrom(view) };
        default:
          view.index = end;
          throw new BebopRuntimeError("Unrecognized discriminator while decoding ModuleData");
      }
    },
  };

  export interface IAction {
    standard: Interface;
    data: IActionData;
  }

  export const Action = {
    encode(message: IAction): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IAction, view: BebopView): number {
      const before = view.length;
        view.writeByte(message.standard);
        ActionData.encodeInto(message.data, view)
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IAction {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IAction {
      let field0: Interface;
      field0 = view.readByte() as Interface;
      let field1: IActionData;
      field1 = ActionData.readFrom(view);
      let message: IAction = {
        standard: field0,
        data: field1,
      };
      return message;
    },
  };

  export interface ICreateIdentity {
    uri: string;
  }

  export const CreateIdentity = {
    discriminator: 1 as 1,
    encode(message: ICreateIdentity): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: ICreateIdentity, view: BebopView): number {
      const before = view.length;
        view.writeString(message.uri);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): ICreateIdentity {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): ICreateIdentity {
      let field0: string;
      field0 = view.readString();
      let message: ICreateIdentity = {
        uri: field0,
      };
      return message;
    },
  };

  export interface IThing {
    bill: number;
  }

  export const Thing = {
    discriminator: 2 as 2,
    encode(message: IThing): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IThing, view: BebopView): number {
      const before = view.length;
        view.writeByte(message.bill);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IThing {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IThing {
      let field0: number;
      field0 = view.readByte();
      let message: IThing = {
        bill: field0,
      };
      return message;
    },
  };

  export type IActionData
    = { discriminator: 1, value: ICreateIdentity }
    | { discriminator: 2, value: IThing };

  export const ActionData = {
    encode(message: IActionData): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IActionData, view: BebopView): number {
      const before = view.length;
        const pos = view.reserveMessageLength();
        const start = view.length + 1;
        view.writeByte(message.discriminator);
        switch (message.discriminator) {
          case 1:
            CreateIdentity.encodeInto(message.value, view);
            break;
          case 2:
            Thing.encodeInto(message.value, view);
            break;
        }
        const end = view.length;
        view.fillMessageLength(pos, end - start);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IActionData {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IActionData {
      const length = view.readMessageLength();
      const end = view.index + 1 + length;
      switch (view.readByte()) {
        case 1:
          return { discriminator: 1, value: CreateIdentity.readFrom(view) };
        case 2:
          return { discriminator: 2, value: Thing.readFrom(view) };
        default:
          view.index = end;
          throw new BebopRuntimeError("Unrecognized discriminator while decoding ActionData");
      }
    },
  };

  export const MAX_MODULES: number = 10;

  export enum OwnershipModel {
    Invalid = 0,
    Single = 1,
    Token = 2,
  }

  export enum RoyaltyModel {
    Invalid = 0,
    Address = 1,
    Fanout = 2,
    Creators = 3,
  }

  export interface IRoyaltyTarget {
    address: Uint8Array;
    share: number;
  }

  export const RoyaltyTarget = {
    encode(message: IRoyaltyTarget): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: IRoyaltyTarget, view: BebopView): number {
      const before = view.length;
        view.writeBytes(message.address);
        view.writeByte(message.share);
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): IRoyaltyTarget {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): IRoyaltyTarget {
      let field0: Uint8Array;
      field0 = view.readBytes();
      let field1: number;
      field1 = view.readByte();
      let message: IRoyaltyTarget = {
        address: field0,
        share: field1,
      };
      return message;
    },
  };

  export interface ICreator {
    address: Uint8Array;
    share: number;
    verified: boolean;
  }

  export const Creator = {
    encode(message: ICreator): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      this.encodeInto(message, view);
      return view.toArray();
    },

    encodeInto(message: ICreator, view: BebopView): number {
      const before = view.length;
        view.writeBytes(message.address);
        view.writeByte(message.share);
        view.writeByte(Number(message.verified));
      const after = view.length;
      return after - before;
    },

    decode(buffer: Uint8Array): ICreator {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      return this.readFrom(view);
    },

    readFrom(view: BebopView): ICreator {
      let field0: Uint8Array;
      field0 = view.readBytes();
      let field1: number;
      field1 = view.readByte();
      let field2: boolean;
      field2 = !!view.readByte();
      let message: ICreator = {
        address: field0,
        share: field1,
        verified: field2,
      };
      return message;
    },
  };

  export enum Lifecycle {
    Invalid = 0,
    Create = 1,
    Transfer = 2,
    Destroy = 3,
    Update = 4,
    Freeze = 5,
    Thaw = 6,
    Split = 7,
    Combine = 8,
    SupplyIncrease = 9,
    SupplyDecrease = 10,
    ActivateExtension = 11,
    DeactivateExtension = 12,
  }

}
